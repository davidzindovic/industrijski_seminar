def David():
  set_safety_mode_transition_hardness(1)
  set_gravity([0.0, 0.0, 9.82])
  set_standard_analog_input_domain(0, 1)
  set_standard_analog_input_domain(1, 1)
  set_tool_analog_input_domain(0, 1)
  set_tool_analog_input_domain(1, 1)
  set_analog_outputdomain(0, 0)
  set_analog_outputdomain(1, 0)
  set_input_actions_to_default()
  set_tcp(p[0.0,0.0,0.1596,0.0,0.0,0.0])
  set_payload(1.14, [-6.0E-4, 0.001, 0.0574])
  set_tool_communication(False, 115200, 0, 1, 1.5, 3.5)
  set_tool_output_mode(0)
  set_tool_digital_output_mode(0, 1)
  set_tool_digital_output_mode(1, 1)
  set_tool_voltage(0)
  step_count_a675a603_c415_4f63_bae3_28c469aacbcc = 0
  thread Step_Counter_Thread_c7a9660e_c5de_4b60_9c68_dbafd1253733():
    while (True):
      step_count_a675a603_c415_4f63_bae3_28c469aacbcc = step_count_a675a603_c415_4f63_bae3_28c469aacbcc + 1
      sync()
    end
  end
  run Step_Counter_Thread_c7a9660e_c5de_4b60_9c68_dbafd1253733()
  # begin: URCap Installation Node
  #   Source: ARCS2, 2.0.5, AIRGATE ApS
  #   Type: ARCS2
  # end: URCap Installation Node
  # begin: URCap Installation Node
  #   Source: External Control, 1.0.5, FZI Research Center for Information Technology
  #   Type: External Control
  # end: URCap Installation Node
  # begin: URCap Installation Node
  #   Source: Robotiq_Grippers, 1.8.3.4198-beta, Robotiq Inc.
  #   Type: Vacuum
  #################################################
  # Vacuum Grip Check
  #################################################
  
  vacuumGripCheckThread1 = 0
  vacuumGripCheckThread2 = 0
  vacuumGripCheckThread3 = 0
  vacuumGripCheckThread4 = 0
  vacuumGripCheckThread1Running = False
  vacuumGripCheckThread2Running = False
  vacuumGripCheckThread3Running = False
  vacuumGripCheckThread4Running = False
  vacuumGripCheckSocketId = "1"
  vacuumGripCheckThreadStarted = False
  
  thread vacuumGripCheck():
    gripper_socket = vacuumGripCheckSocketId
    vacuumGripCheckThreadStarted = True
  
    while (True):
      objectDetectedDebounceCtr = 0
  
      while (objectDetectedDebounceCtr < 3):
        if(rq_is_vacuum_obj_detected(gripper_socket="1")):
          objectDetectedDebounceCtr = objectDetectedDebounceCtr + 1
        else:
          objectDetectedDebounceCtr = 0
        end
        sleep(0.1)
      end
  
      objectNotDetectedDebounceCtr = 0
  
      while objectNotDetectedDebounceCtr < 3:
        if (not rq_is_vacuum_obj_detected(gripper_socket="1")):
          objectNotDetectedDebounceCtr = objectNotDetectedDebounceCtr + 1
        else:
          objectNotDetectedDebounceCtr = 0
        end
        sleep(0.1)
      end
  
      socket_open("127.0.0.1",29999,"dashboardServerSocket")
      socket_send_line("pause","dashboardServerSocket")
      socket_send_string("popup Vacuum grip check has detected an object drop.", "dashboardServerSocket")
      socket_send_byte(10, "dashboardServerSocket")
      socket_close("dashboardServerSocket")
  
      sync()
    end
  end
  
  def startVacuumGripCheckThread(gripperId="1"):
    vacuumGripCheckSocketId = gripperId
    threadHandle = run vacuumGripCheck()
    waitForVacuumGripCheckThreadStarted()
    return threadHandle
  end
  
  def stopVacuumGripCheckThread(threadHandle):
    kill threadHandle
  end
  
  def waitForVacuumGripCheckThreadStarted():
    while (not(vacuumGripCheckThreadStarted)):
      sync()
    end
    vacuumGripCheckThreadStarted = False
  end
  #################################################
  # End - Vacuum Grip Check
  #################################################
  
  #################################################
  # Stops the pump on a distance travelled
  #################################################
  global stopPumpDistance = 100
  global stopPumpSocketId = "0"
  global stopPumpThreadStarted = [False, False, False, False]
  global stopPumpThreadHandles = [0, 0, 0, 0]
  
  thread stopPumpOnDistanceTravelled():
    distance = stopPumpDistance
    socketId = stopPumpSocketId
    stopPumpThreadStarted[rq_socket_to_index(socketId)] = True
  
    measuredDistance = waitForDistanceTravelled(distance)
  
    rq_stop(socketId)
  
    stopPumpThreadStarted[rq_socket_to_index(socketId)] = False
  end
  
  def waitForDistanceTravelled(distance):
    startingPose = get_actual_tcp_pose()
    measuredDistance = 0
    while (measuredDistance < distance):
      sleep(0.1)
      measuredDistance = point_dist(get_actual_tcp_pose(), startingPose)
    end
  
    return measuredDistance
  end
  
  def startStopPumpOnDistanceTravelledThread(distance, gripper_socket="1"):
    if (stopPumpThreadStarted[rq_socket_to_index(gripper_socket)]):
      return 0
    end
  
    global stopPumpDistance = distance
    global stopPumpSocketId = gripper_socket
    stopPumpThreadHandles[rq_socket_to_index(gripper_socket)] = run stopPumpOnDistanceTravelled()
    waitForStopPumpOnDistanceTravelledThreadStarted(gripper_socket)
    return stopPumpThreadHandles[rq_socket_to_index(gripper_socket)]
  end
  
  def waitForStopPumpOnDistanceTravelledThreadStarted(gripper_socket="1"):
    while (not(stopPumpThreadStarted[rq_socket_to_index(gripper_socket)])):
      sync()
    end
  end
  
  def stopStopPumpOnDistanceTravelledThread(gripper_socket="1"):
    handle = stopPumpThreadHandles[rq_socket_to_index(gripper_socket)]
    threadIsRunning = stopPumpThreadStarted[rq_socket_to_index(gripper_socket)]
    if (threadIsRunning):
      kill handle
      clear_socket_buffer(gripper_socket, 0.01)
      stopPumpThreadHandles[rq_socket_to_index(gripper_socket)] = 0
    end
  end
  #################################################
  # End - Stops the pump on a distance travelled
  #################################################
  
  #################################################
  # Vacuum general functions
  #################################################
  def rq_wait_for_vacuum_object_detected(gripper_socket="1"):
      while (not rq_is_vacuum_obj_detected(gripper_socket)):
          if (rq_is_vacuum_timeout(gripper_socket)):
              return False
          end
          sync()
      end
      return True
  end
  
  def rq_wait_for_vacuum_object_secured(gripper_socket="1"):
      while (not rq_is_vacuum_obj_secured(gripper_socket)):
          if (rq_is_vacuum_timeout(gripper_socket)):
              return False
          end
          sync()
      end
      return True
  end
  
  def rq_wait_for_vacuum_object_suction_complete(gripper_socket="1"):
      remaining_retries = 50
  
       # Wait for suction started
      while (not rq_is_vacuum_obj_in_suction(gripper_socket) and
             not rq_is_vacuum_obj_detected(gripper_socket) and
             remaining_retries > 0):
          sleep(0.01)
          remaining_retries = remaining_retries - 1
      end
  
      # Wait for suction completed
      while (rq_is_vacuum_obj_in_suction(gripper_socket)):
          if (rq_is_vacuum_timeout(gripper_socket)):
              return False
          end
          sleep(0.01)
      end
  
      return True
  end
  
  def rq_wait_for_vacuum_object_not_detected(gripper_socket="1"):
      while (rq_is_vacuum_obj_detected(gripper_socket)):
          sleep(0.01)
      end
  end
  
  def rq_is_vacuum_obj_detected(gripper_socket="1"):
      gOBJ = rq_get_var("OBJ", 1, gripper_socket)
      sync()
      return is_vacuum_OBJ_object_detected(gOBJ)
  end
  
  def rq_is_vacuum_obj_secured(gripper_socket="1"):
      gOBJ = rq_get_var("OBJ", 1, gripper_socket)
      sync()
      return is_vacuum_OBJ_object_secured(gOBJ)
  end
  
  def rq_is_vacuum_obj_in_suction(gripper_socket="1"):
      gOBJ = rq_get_var("OBJ", 1, gripper_socket)
      sync()
  
      if(is_vacuum_OBJ_object_in_motion(gOBJ)):
          return True
      else:
          return False
      end
  end
  
  def rq_is_vacuum_timeout(gripper_socket="1"):
      gFLT = rq_get_var("FLT", 2, gripper_socket)
      sync()
  
      if(gFLT ==6):
          return True
      end
  
      return False
  end
  
  def is_vacuum_OBJ_object_in_motion(gOBJ):
      if (gOBJ == 0):
          return True
      end
  
      return False
  end
  
  def is_vacuum_OBJ_object_detected(gOBJ):
      if (gOBJ == 1 or gOBJ == 2):
          return True
      end
  
      return False
  end
  
  def is_vacuum_OBJ_object_secured(gOBJ):
      if (gOBJ == 2):
          return True
      end
  
      return False
  end
  
  def rq_set_pressure_timeout_minimum_vacuum(pressure, timeout, minimum, gripper_socket="1"):
      rq_set_pos_spd_for(pressure, timeout, minimum, gripper_socket)
  end
  
  def is_FLT_vacuum_timeout(gFLT):
    if (gFLT == 6):
        return True
    end
  
    return False
  end
  
  def is_continuous_grip(maximum_vacuum):
    return maximum_vacuum == 0
  end
  
  def rq_vacuum_release(advanced_mode=False, shutoff_distance_cm=5, wait_for_object_released=True, gripper_socket="1"):
    local shutoff_distance = scale(shutoff_distance_cm, [0, 99], [0.00, 0.99])
    local pressure = 255
    local minimum = 0
    local timeout = 255
    rq_vacuum_release_raw(advanced_mode, pressure, minimum, timeout, shutoff_distance, wait_for_object_released, gripper_socket)
  end
  
  def rq_vacuum_release_raw(advanced_mode, pressure, minimum, timeout, shutoff_distance, wait_for_object_released, gripper_socket):
    rq_reset_fault_and_activate(gripper_socket)
    rq_set_pressure_timeout_minimum_vacuum(pressure, timeout, minimum, gripper_socket)
  
    if advanced_mode:
      rq_set_gripper_mode(1, gripper_socket)
    else:
      rq_set_gripper_mode(0, gripper_socket)
    end
  
    rq_set_GTO_and_wait(1, gripper_socket)
  
    if wait_for_object_released:
      while (rq_is_vacuum_obj_detected(gripper_socket)):
        rq_set_pressure_timeout_minimum_vacuum(pressure, timeout, minimum, gripper_socket)
  
        if advanced_mode:
          rq_set_gripper_mode(1, gripper_socket)
        else:
          rq_set_gripper_mode(0, gripper_socket)
        end
  
        rq_set_GTO_and_wait(1, gripper_socket)
        sleep(0.01)
      end
    end
  
    if advanced_mode:
      startStopPumpOnDistanceTravelledThread(shutoff_distance, gripper_socket)
    end
  end
  
  def rq_vacuum_grip(advanced_mode=False, maximum_vacuum=60, minimum_vacuum=40, timeout_ms=3000, wait_for_object_detected=True, gripper_socket="1"):
    local pressure = scale(maximum_vacuum, [0, 100], [100, 0])
    local minimum = scale(minimum_vacuum, [0, 100], [100, 0])
    local timeout = scale(timeout_ms, [0, 25500], [0, 255])
    rq_vacuum_grip_raw(advanced_mode, pressure, minimum, timeout, gripper_socket)
    if wait_for_object_detected:
          suction_completed = rq_wait_for_vacuum_object_suction_complete(gripper_socket)
          if(not suction_completed):
              rq_set_var("GTO", 0, gripper_socket)
          end
    end
  end
  
  def rq_vacuum_grip_raw(advanced_mode, pressure, minimum, timeout, gripper_socket):
    stopStopPumpOnDistanceTravelledThread(gripper_socket)
    rq_reset_fault_and_activate(gripper_socket)
  
    rq_set_pressure_timeout_minimum_vacuum(pressure, timeout, minimum, gripper_socket)
  
    if advanced_mode:
      rq_set_gripper_mode(1, gripper_socket)
    else:
      rq_set_gripper_mode(0, gripper_socket)
    end
  
    rq_set_GTO_and_wait(1, gripper_socket)
  
  end
  
  def rq_reset_fault_and_activate(gripper_socket):
      gFLT = rq_get_var("FLT", 2, gripper_socket)
  
      if(not is_FLT_no_fault(gFLT)):
          if(is_FLT_vacuum_timeout(gFLT)):
              rq_set_GTO_and_wait(0, gripper_socket)
          elif(is_FLT_faulted(gFLT)):
              rq_set_GTO_and_wait(0, gripper_socket)
              rq_set_var("ACT", 1, gripper_socket)
          end
      elif(not rq_is_gripper_activated(gripper_socket)):
          rq_set_GTO_and_wait(0, gripper_socket)
          rq_set_var("ACT", 1, gripper_socket)
      end
  end
  #################################################
  # End - Vacuum general functions
  #################################################
  vacuumGripCheckWarningTitle = "Vacuum grip check"
  vacuumGripCheckWarningMessage = "Vacuum gripper object lost"
  vacuumGripTimeoutTitle = "Vacuum gripper fault"
  vacuumGripTimeoutMessage = "Grip has timed out"
  # end: URCap Installation Node
  # begin: URCap Installation Node
  #   Source: Robotiq_Wrist_Camera, 1.11.3.13312, Robotiq Inc.
  #   Type: Camera
  
  ###########################################
  #######Vision urcap preamble start########
  
  logging_service = rpc_factory("xmlrpc","http://127.0.0.1:4747")
  # Converts a pose relative to the flange in the base frame.
  def get_T_in_base_from_flange(T_x_in_flange):
  
    T_flange_in_base = get_actual_tool_flange_pose()
  
    T_x_in_base = pose_trans(T_flange_in_base, T_x_in_flange)
  
    return T_x_in_base
  end
  
  # Search pose cartesian (camera pose)
  T_camera_in_flange = p[0.0, 0.05, 0.05, -0.5, 0.0, 0.0]
  snapshot_position_offset = p[0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
  ignore_snapshot_position = False
  canSaveImage = False
  
  # Open connection with vision service
  xmlrpc_server=rpc_factory("xmlrpc","http://127.0.0.1:4242")
  
  # Open connection with visual offset monitor
  cam_locate_monitor=rpc_factory("xmlrpc","http://127.0.0.1:35155")
  
  # Open connection with visual offset monitor
  visual_offset_monitor=rpc_factory("xmlrpc","http://127.0.0.1:43899")
  
  #######Vision urcap preamble end##########
  ###########################################
  
  # end: URCap Installation Node
  # begin: URCap Installation Node
  #   Source: Robotiq_Copilot, 1.14.4.3276, Robotiq Inc.
  #   Type: Copilot
  ###############################################################
  # Script file used to communicate with Robotiq's ft sensor
  # Version: 0.0.1
  ###############################################################

  node_rpc_server = rpc_factory("xmlrpc","http://localhost:4251/node")
  linalg = rpc_factory("xmlrpc","http://localhost:4251/linalg")
  storevar = rpc_factory("xmlrpc","http://localhost:4251/storevariable")

  global Fx = 0.0
  global Fy = 0.0
  global Fz = 0.0
  global Mx = 0.0
  global My = 0.0
  global Mz = 0.0
  global T_base_sensor = p[0,0,0,0,0,0]
  global tcp_wrench = [0,0,0,0,0,0]
  global base_wrench = [0,0,0,0,0,0]
  global rq_target_joint_positions = get_actual_joint_positions()
  global rq_ft_sensor_connected = False
  global rq_active_node = 0
  global rq_elapsed_time = 0
  rq_force_protect_urcap = 0.0
  rq_torque_protect_urcap = 0.0
  rq_collision_detection_enabled = False
  rq_collision_detection_active_time = 0.0
  rq_halt_on_collision_detection = True
  sensor_wrench = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
  rq_node_executor_thread_running = False
  rq_lookahead_time = 0.05

  rq_controller_time_step = get_steptime()

  def pose_to_list(p):
    return [p[0], p[1], p[2], p[3], p[4], p[5]]
  end

  def rq_init_path(pathId):
     initPathAnswer = node_rpc_server.initpath(pathId)
     verify_path_answer(initPathAnswer)
     return initPathAnswer[0]
  end

  def setup_force_node_on_server(generic_rq_insertion_force_node_id = 1,
                                 feature=1,
                                 targetforce = [0,0,0,0,0,0],
                                 force_control_enabled_axes = [False, False, False, False, False, False],
                                 max_negative_deviation_vector = [-0.1, -0.1, -0.1, -0.1, -0.1, -0.1],
                                 max_positive_deviation_vector = [0.1, 0.1, 0.1, 0.1, 0.1, 0.1],
                                 adaptiveStiffness = True):
    node_rpc_server.setforcecontrolfeature(generic_rq_insertion_force_node_id, feature)
    node_rpc_server.setforcecontroltargetforce(generic_rq_insertion_force_node_id, targetforce)
    node_rpc_server.setforcecontrolenabledaxes(generic_rq_insertion_force_node_id, force_control_enabled_axes)
    node_rpc_server.setforcecontrolmaximaldeviation(generic_rq_insertion_force_node_id, max_negative_deviation_vector, max_positive_deviation_vector)
    node_rpc_server.setforcecontroladaptivestiffnessenabledaxes(generic_rq_insertion_force_node_id, True)
  end

  def verify_path_answer(path_answer):
   initPathStatusCode = path_answer[1]
   handle_path_node_error_code(initPathStatusCode)
  end

  def handle_path_node_error_code(initPathStatusCode):
    if initPathStatusCode == -1:
      popup("Could not compute path with the selected options.", "Robotiq's FT Sensor", error=True)
    elif initPathStatusCode == 1:
      popup("Joint solution impossible. Change your starting position.", "Robotiq's FT Sensor", error=True)
    elif initPathStatusCode == 2:
      popup("Discontinuous path detected. Change your starting position.", "Robotiq's FT Sensor", error=True)
    elif initPathStatusCode == 3:
      popup("Path time limit has been reached. Increase the speed of your path or break it down in multiple shorter paths.", "Robotiq's FT Sensor", error=True)
    elif initPathStatusCode == 4:
      popup("Could not compute path with the selected options. Computing path timeout.", "Robotiq's FT Sensor", error=True)
    elif initPathStatusCode == 5:
      popup("Path computation was aborted.", "Robotiq's FT Sensor", error=True)
    elif initPathStatusCode == 6:
      popup("A previous path computation is still in progress. Please try again in a few seconds.", "Robotiq's FT Sensor", error=True)
    elif initPathStatusCode == 7:
      textmsg("Path initialization error: Invalid path id.") # No popup needed in this case.
    elif initPathStatusCode == 8:
      popup("Palletizer error: box number out of range.")
    elif initPathStatusCode == 9:
      popup("Palletizer error: collision detected.")
    end
    if initPathStatusCode != 0:
      halt
    end
  end


  def rq_wait_ft_sensor_steady(timeout = 2000):

    max_mean_squared_error = [0.1, 0.1, 0.1, 0.0001, 0.0001, 0.0001]
    mean = sensor_wrench

    mean_squared_error = sensor_wrench
    i=0
    while i<6:
      mean_squared_error[i] = mean_squared_error[i] * mean_squared_error[i]
      i=i+1
    end

    is_sensor_steady = False
    alpha = 0.9
    timer = 0

    while (not is_sensor_steady) and (timer < timeout):
      sleep(0.008)
      timer = timer + 8

      i = 0
      while i < 6:
        mean[i] = alpha * mean[i] + (1.0 - alpha) * sensor_wrench[i]
        error = sensor_wrench[i] - mean[i]
        mean_squared_error[i] = alpha * mean_squared_error[i] + ((1.0 - alpha) * error * error)
        i = i+1
      end

      is_sensor_steady = True
      i = 0
      while (i < 6) and is_sensor_steady:
        is_sensor_steady = mean_squared_error[i] < max_mean_squared_error[i]
        i = i+1
      end
    end

    return is_sensor_steady
  end

  thread rq_elapsed_timer_ms():
    rq_elapsed_time = 0
  dt = 1000/500
    while True:
      rq_elapsed_time =  rq_elapsed_time + dt
      sync()
    end
  end

  def get_sensor_fx():
    return Fx
  end

  def get_sensor_fy():
    return Fy
  end

  def get_sensor_fz():
    return Fz
  end

  def get_sensor_mx():
    return Mx
  end

  def get_sensor_my():
    return My
  end

  def get_sensor_mz():
    return Mz
  end

  def get_applied_tcp_force(index):
    return -1.0 * tcp_wrench[index]
  end

  def get_applied_base_force(index):
    return -1.0 * base_wrench[index]
  end

  def express_vector_in_new_frame(T_from_to, V_from):
    Q_from_to = p[0, 0, 0, T_from_to[3], T_from_to[4], T_from_to[5]]
    V_to = pose_trans(pose_inv(Q_from_to), p[V_from[0], V_from[1], V_from[2], 0, 0, 0])
    return [V_to[0], V_to[1], V_to[2]]
  end

  def express_force_in_frame(T_from_to, wrench_from):
    F = express_vector_in_new_frame(T_from_to, [wrench_from[0], wrench_from[1], wrench_from[2]])
    T = express_vector_in_new_frame(T_from_to, [wrench_from[3], wrench_from[4], wrench_from[5]])
    return [F[0], F[1], F[2], T[0], T[1], T[2]]
  end

  thread read_force():


    if (not socket_open("127.0.0.1", 29999, "RQDashboardClient")):
      popup("Can't connect to the Dashboard server", "Robotiq's FT Sensor", error=True)
      halt
    end

    rq_collision_detection_active_count = 0
    rq_collision_detection_active = False

    while True:

        T_base_tcp = get_actual_tcp_pose()
        T_base_flange = get_actual_tool_flange_pose()
        T_flange_sensor = p[0, 0, 0, 0, 0, 0]
        T_base_sensor = pose_trans(T_base_flange, T_flange_sensor)

        T_flange_tcp = pose_trans( pose_inv(T_base_flange), T_base_tcp)
        T_sensor_tcp = pose_trans( pose_inv(T_flange_sensor), T_flange_tcp)

        sensor_wrench = express_force_in_frame(T_base_sensor, get_tcp_force())
        tcp_wrench = wrench_trans(pose_inv(T_sensor_tcp), sensor_wrench)
        base_wrench = express_force_in_frame(pose_inv(T_base_tcp), tcp_wrench)

        Fx = sensor_wrench[0]
        Fy = sensor_wrench[1]
        Fz = sensor_wrench[2]
        Mx = sensor_wrench[3]
        My = sensor_wrench[4]
        Mz = sensor_wrench[5]

        write_output_float_register(TCP_FX_ACTUAL_OUTPUT_DOUBLE, tcp_wrench[0])
        write_output_float_register(TCP_FY_ACTUAL_OUTPUT_DOUBLE, tcp_wrench[1])
        write_output_float_register(TCP_FZ_ACTUAL_OUTPUT_DOUBLE, tcp_wrench[2])
        write_output_float_register(TCP_MX_ACTUAL_OUTPUT_DOUBLE, tcp_wrench[3])
        write_output_float_register(TCP_MY_ACTUAL_OUTPUT_DOUBLE, tcp_wrench[4])
        write_output_float_register(TCP_MZ_ACTUAL_OUTPUT_DOUBLE, tcp_wrench[5])

        if rq_collision_detection_enabled:
            if rq_collision_detection_active_time < (0.5*rq_controller_time_step):
                if norm([Fx, Fy, Fz]) > rq_force_protect_urcap:
                    rq_on_collision_detection("Force limit value exceeded.")
                elif norm([Mx, My, Mz]) > rq_torque_protect_urcap:
                    rq_on_collision_detection("Torque limit value exceeded.")
                end
            else:
                rq_collision_detection_active_time = rq_collision_detection_active_time + rq_controller_time_step
                if rq_collision_detection_active_time >= 1.0:
                    rq_collision_detection_active_time = 0.0
                end
            end
        end

        sync()

    end
  end

  def rq_get_ft_sensor_state():
    socket_open("127.0.0.1",63350,"rq_ft_sensor_state")
    socket_send_string("CURRENT STATE", "rq_ft_sensor_state")
    rq_sensor_state = socket_read_string("rq_ft_sensor_state")
    socket_close("rq_ft_sensor_state")

    if rq_sensor_state == "":
      rq_sensor_state = "RQ_STATE_INIT"
    end

    return rq_sensor_state
  end

  def rq_ft_sensor_disconnected_warn_user():
    socket_open("127.0.0.1",29999,"SensorWarning")
    socket_send_string("popup FT Sensor must be connected to run this program.","SensorWarning")
    socket_send_byte(10,"SensorWarning")
    socket_close("SensorWarning")
  end

  def rq_ft_sensor_disconnected_stop_program():
    socket_open("127.0.0.1", 30002, "rq_ft_sensor_stop_socket")

    socket_send_string("def rq_ft_sensor_stop_program():", "rq_ft_sensor_stop_socket")
    socket_send_byte(10, "rq_ft_sensor_stop_socket")
    socket_send_string("  stopj(5.0)", "rq_ft_sensor_stop_socket")
    socket_send_byte(10, "rq_ft_sensor_stop_socket")
    socket_send_string("end", "rq_ft_sensor_stop_socket")
    socket_send_byte(10, "rq_ft_sensor_stop_socket")

    socket_close("rq_ft_sensor_stop_socket")
  end

  def rq_ft_sensor_disconnected_check():
    if rq_get_ft_sensor_state() == "RQ_STATE_INIT":
      rq_ft_sensor_disconnected_stop_program()
      rq_ft_sensor_disconnected_warn_user()

      return True
    else:
      return False
    end
  end

  #RTDE input registers
  TARGET_JOINT_0_INPUT_REGISTER_DOUBLE = 40
  TARGET_JOINT_1_INPUT_REGISTER_DOUBLE = 41
  TARGET_JOINT_2_INPUT_REGISTER_DOUBLE = 42
  TARGET_JOINT_3_INPUT_REGISTER_DOUBLE = 43
  TARGET_JOINT_4_INPUT_REGISTER_DOUBLE = 44
  TARGET_JOINT_5_INPUT_REGISTER_DOUBLE = 45
  FINISH_NODE_INPUT_REGISTER_INT32 = 40
  LICENSING_ERROR_INPUT_REGISTER_INT32 = 41
  ACTIVATION_NODE_COUNT_INPUT_REGISTER_INT32 = 42

  #RTDE output registers
  ACTIVE_NODE_OUTPUT_REGISTER_INT32 = 0
  NODE_EXECUTION_OUTPUT_COUNT_INT32 = 1
  ACTIVATION_NODE_COUNT_OUTPUT_REGISTER_INT32 = 2
  TCP_FX_ACTUAL_OUTPUT_DOUBLE = 0
  TCP_FY_ACTUAL_OUTPUT_DOUBLE = 1
  TCP_FZ_ACTUAL_OUTPUT_DOUBLE = 2
  TCP_MX_ACTUAL_OUTPUT_DOUBLE = 3
  TCP_MY_ACTUAL_OUTPUT_DOUBLE = 4
  TCP_MZ_ACTUAL_OUTPUT_DOUBLE = 5
  GENERAL_OUTPUT_DOUBLE_6 = 6
  GENERAL_OUTPUT_DOUBLE_7 = 7
  GENERAL_OUTPUT_DOUBLE_8 = 8
  GENERAL_OUTPUT_DOUBLE_9 = 9
  GENERAL_OUTPUT_DOUBLE_10 = 10
  GENERAL_OUTPUT_DOUBLE_11 = 11

  write_output_integer_register(ACTIVE_NODE_OUTPUT_REGISTER_INT32, 0)
  write_output_integer_register(NODE_EXECUTION_OUTPUT_COUNT_INT32, 0)
  write_output_integer_register(ACTIVATION_NODE_COUNT_OUTPUT_REGISTER_INT32, 0)
  write_output_float_register(TCP_FX_ACTUAL_OUTPUT_DOUBLE, 0)
  write_output_float_register(TCP_FY_ACTUAL_OUTPUT_DOUBLE, 0)
  write_output_float_register(TCP_FZ_ACTUAL_OUTPUT_DOUBLE, 0)
  write_output_float_register(TCP_MX_ACTUAL_OUTPUT_DOUBLE, 0)
  write_output_float_register(TCP_MY_ACTUAL_OUTPUT_DOUBLE, 0)
  write_output_float_register(TCP_MZ_ACTUAL_OUTPUT_DOUBLE, 0)

  global activation_node_count = 0
  global node_execution_count = 0

  def element_wise_subtract(l1, l2):
    global r = l1
    i=0
    while i<length(r):
      r[i]=l1[i]-l2[i]
      i=i+1
    end
    return r
  end

  def list_by_scalar_multiply(l1, scalar):
      global r = l1
      i=0
      while i<length(r):
        r[i]=l1[i]*scalar
        i=i+1
      end
      return r
   end

  def norm_inf(v):
    norm = 0
    i=0
    while i<length(v):
        n = norm(v[i])
        if(n > norm):
          norm = n
        end
      i=i+1
    end
    return norm
  end

  def active_and_reset_node(nodeId):
    server_activation_node_count = read_input_integer_register(ACTIVATION_NODE_COUNT_INPUT_REGISTER_INT32)

    activation_node_count = activation_node_count + 1
    node_execution_count = 0
    write_output_integer_register(NODE_EXECUTION_OUTPUT_COUNT_INT32, node_execution_count)
    rq_active_node = nodeId
    write_output_integer_register(ACTIVE_NODE_OUTPUT_REGISTER_INT32, nodeId)
    write_output_integer_register(ACTIVATION_NODE_COUNT_OUTPUT_REGISTER_INT32, activation_node_count)

    while server_activation_node_count == read_input_integer_register(ACTIVATION_NODE_COUNT_INPUT_REGISTER_INT32):
      sync()
    end
  end

  def execute_node(nodeId, startThread = False):
    node_execution_thread = 0
    active_and_reset_node(nodeId)
    if startThread:
      rq_target_joint_positions = get_actual_joint_positions()
      movej(rq_target_joint_positions) # This movej is used to prevent the "another thread is already controlling the robot" error.
      node_execution_thread = run execute_node_thread()
    end
    while not active_node_completed():
      sync()
    end
    return node_execution_thread
  end

  def setup_node_execution_related_variables():
    activation_node_count = 0
    node_execution_count = 0
    write_output_integer_register(ACTIVE_NODE_OUTPUT_REGISTER_INT32, 0)
    write_output_integer_register(ACTIVATION_NODE_COUNT_OUTPUT_REGISTER_INT32, activation_node_count)
    write_output_integer_register(NODE_EXECUTION_OUTPUT_COUNT_INT32, node_execution_count)
    sync()
  end

  def start_node_executor():
    setup_node_execution_related_variables()

    succeeded = node_rpc_server.startnodeexecutor()
    if not succeeded:
      node_rpc_server.stopnodeexecutor()
      succeeded = node_rpc_server.startnodeexecutor()
      if not succeeded:
        popup("RTDE interface cannot initialize. Make sure that Ethernet/IP adapter and Profinet are disabled, and that no other URCaps use the RTDE interface.", "Robotiq Copilot", error=True)
        halt
      end
    end

    hand_shake_xmlrpcserver()
  end

  def reset_node_executor():
    setup_node_execution_related_variables()

    succeeded = node_rpc_server.resetnodeexecutor()
    if not succeeded:
      popup("RTDE interface cannot initialize. Make sure that Ethernet/IP adapter and Profinet are disabled, and that no other URCaps use the RTDE interface.", "Robotiq Copilot", error=True)
      halt
    end

    hand_shake_xmlrpcserver()
  end

  def hand_shake_xmlrpcserver():
    timer_thread = run rq_elapsed_timer_ms()
    sync()
    node_execution_initialized = False
    while (not node_execution_initialized) and (rq_elapsed_time < 100):
      node_execution_initialized = (read_input_integer_register(FINISH_NODE_INPUT_REGISTER_INT32) == -1)
      sync()
    end
    kill timer_thread

    if (not node_execution_initialized):
      popup("Node Execution initialization failed.", "Robotiq Copilot", error=True)
      halt
    end
  end

  thread execute_node_thread():
    rq_target_joint_positions = get_actual_joint_positions()
    servoj(rq_target_joint_positions)
    while True:
      new_rq_target_joint_positions = update_target_position()
      joint_target_distances = element_wise_subtract(rq_target_joint_positions, new_rq_target_joint_positions)
      max_joint_target_displacement = norm_inf(joint_target_distances)
      if max_joint_target_displacement > 0.2:
          textmsg("previous target position: ", rq_target_joint_positions)
          textmsg("next target position: ", new_rq_target_joint_positions)
          textmsg("max joint target displacement: ", max_joint_target_displacement)
          popup("Node executor error: see Log tab for details", "Robotiq Copilot", False, True, True)
          halt
      end
      servoj(new_rq_target_joint_positions, t=0.008, lookahead_time=rq_lookahead_time, gain=500)
      rq_target_joint_positions = new_rq_target_joint_positions
    end
  end

  # The thread below is used to prevent "another thread is already controlling the robot error".
  # In some occasions, even a sleep(0.05) will not work so this is necessary (until fixed by UR).
  # The thread is immediately killed to avoid unnecessary motion for the case of a parent node
  # that modifies the servoj target joint positions.
  def kill_thread( thread_id ):
    kill thread_id
    run_movej_thread = run movej_thread()
    sync()
    kill run_movej_thread
  end

  thread movej_thread():
    movej(rq_target_joint_positions)
  end

  def active_node_completed():
    return (read_input_integer_register(ACTIVATION_NODE_COUNT_INPUT_REGISTER_INT32) == activation_node_count) and
           (read_input_integer_register(FINISH_NODE_INPUT_REGISTER_INT32) == rq_active_node)
  end

  def update_target_position():

    if read_input_integer_register(LICENSING_ERROR_INPUT_REGISTER_INT32):
        popup("Robotiq license error!", "Robotiq Copilot", error=True)
        halt
    end

    new_rq_target_joint_positions = [0,0,0,0,0,0]
    new_rq_target_joint_positions[0] = read_input_float_register(TARGET_JOINT_0_INPUT_REGISTER_DOUBLE)
    new_rq_target_joint_positions[1] = read_input_float_register(TARGET_JOINT_1_INPUT_REGISTER_DOUBLE)
    new_rq_target_joint_positions[2] = read_input_float_register(TARGET_JOINT_2_INPUT_REGISTER_DOUBLE)
    new_rq_target_joint_positions[3] = read_input_float_register(TARGET_JOINT_3_INPUT_REGISTER_DOUBLE)
    new_rq_target_joint_positions[4] = read_input_float_register(TARGET_JOINT_4_INPUT_REGISTER_DOUBLE)
    new_rq_target_joint_positions[5] = read_input_float_register(TARGET_JOINT_5_INPUT_REGISTER_DOUBLE)

    node_execution_count = node_execution_count + 1
    write_output_integer_register(NODE_EXECUTION_OUTPUT_COUNT_INT32, node_execution_count)
    return new_rq_target_joint_positions
  end

  def set_servoj_node_cmd(q):
    write_output_float_register(GENERAL_OUTPUT_DOUBLE_6, q[0])
    write_output_float_register(GENERAL_OUTPUT_DOUBLE_7, q[1])
    write_output_float_register(GENERAL_OUTPUT_DOUBLE_8, q[2])
    write_output_float_register(GENERAL_OUTPUT_DOUBLE_9, q[3])
    write_output_float_register(GENERAL_OUTPUT_DOUBLE_10, q[4])
    write_output_float_register(GENERAL_OUTPUT_DOUBLE_11, q[5])
  end

  def rq_collision_detection_start(force_limit = 140, torque_limit = 14, halt_on_collision = True):
    rq_force_protect_urcap = force_limit
    rq_torque_protect_urcap = torque_limit
    rq_collision_detection_active_time = 0.0
    rq_collision_detection_enabled = True
    rq_halt_on_collision_detection = halt_on_collision
  end

  def rq_collision_detection_stop():
    rq_collision_detection_enabled = False
  end

  def rq_on_collision_detection(message):
    textmsg("Collision Detection. " + message)
    popupTitle = "Collision Detection"
    if rq_halt_on_collision_detection:
      popup(message + " Program halt.", popupTitle, False, True, False)
      halt
    else:
      popup(message + " Program suspend.", popupTitle, True, False, False)
      socket_send_line("pause", "RQDashboardClient")
      rq_collision_detection_active_time = rq_controller_time_step
    end
  end

  ################################
  # MAIN
  ################################

  run read_force()
  start_node_executor()
  
  #***********************************************************************************************
  # verify tap detection
  #***********************************************************************************************
  
  def rq_tap_count(forces, high_threshold):
  
    low_threshold = 2
    tapCount = 0
    lookingForPeak = True
    indexDown = 0
  
    i = 1
    lastIndex = length(forces) - 1
    while i <= lastIndex:
  
      deltaForce = forces[i] - forces[0]
  
     if lookingForPeak:
        if deltaForce >  high_threshold:
          lookingForPeak = False
        end
      else:
        if deltaForce < low_threshold:
          tapCount = tapCount + 1
          lookingForPeak = True
          indexDown = i
        end
      end
      i = i + 1
  
    end
  
    if indexDown != lastIndex:
      tapCount = 0
    end
  
    return tapCount
  
  end
  def shift_right(list, default_value = 0):
  
     i = length(list)-1
     while (i > 0):
        list[i]=list[i-1]
        i=i-1
     end
     list[0] = default_value
  
     return list
  end
  
  #***********************************************************************************************
  # Wait for force reached
  #***********************************************************************************************
  # desired_wrench : desired wrench
  # is_active      : list of 0 and 1, 1 : axis is controlled
  # feature        : 0:base, 1:tcp
  # timeout        : timeout in miliseconds
  #***********************************************************************************************
  def rq_wait_for_force_reached(desired_wrench, is_active, feature, timeout):
  
    feature_base = 0
    feature_tool = 1
    time_constant = 0.025
    alpha = 1 - pow(2.718, -1.0 * get_steptime() / time_constant)
  
    thresholds = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
    minimal_thresholds = [1.0, 1.0, 1.0, 0.1, 0.1, 0.1]
  
    applied_wrench = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
    filtered_wrench = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
  
    if (feature == feature_base):
      applied_wrench = list_by_scalar_multiply(base_wrench, -1.0)
    else:
      applied_wrench = list_by_scalar_multiply(tcp_wrench, -1.0)
    end
    filtered_wrench = applied_wrench
  
    i = 0
    while (i < 6):
      if (is_active[i]):
        thresholds[i] = 0.05 * norm(desired_wrench[i])
        if thresholds[i] < minimal_thresholds[i]:
          thresholds[i] = minimal_thresholds[i]
        end
      else:
        thresholds[i] = 10000
      end
      i = i+1
    end
  
   force_reached = False
  
   timer = 0
  
   while ((not force_reached) and (timer < timeout)):
  
      if (feature == feature_base):
         applied_wrench = list_by_scalar_multiply(base_wrench, -1.0)
      else:
         applied_wrench = list_by_scalar_multiply(tcp_wrench, -1.0)
      end
  
      i = 0
      while (i < 6):
        filtered_wrench[i] = (alpha * applied_wrench[i]) + ((1.0 - alpha) * filtered_wrench[i])
        i = i+1
      end
  
      force_reached = True
  
      i = 0
      while ((i < 6) and force_reached):
        error = norm(desired_wrench[i] - filtered_wrench[i])
        if (error > thresholds[i]):
          force_reached = False
        end
        i = i + 1
      end
  
      timer = timer + get_steptime()
  
      sync()
  
    end
  
    return force_reached
  end
  #***********************************************************************************************
  # verify click detection
  #***********************************************************************************************
  click_detection_children_ended = False
  
  def rq_click_detection(force_drop_threshold = 10, torque_drop_threshold = 1, force_radio_button_selected = True):
  
    current_norm = 0
    drop_threshold = 0
    norms = [0.0, 0.0, 0.0, 0.0, 0.0]
    click_detected = False
    wrench_indices = [0,0,0]
  
    if(force_radio_button_selected):
      drop_threshold = force_drop_threshold
      wrench_indices = [0,1,2]
    else:
      drop_threshold =torque_drop_threshold
      wrench_indices = [3,4,5]
    end
  
    while ((not click_detection_children_ended) and (not click_detected)):
  
      current_norm = norm([sensor_wrench[wrench_indices[0]], sensor_wrench[wrench_indices[1]], sensor_wrench[wrench_indices[2]]])
  
      norms[4] = norms[3]
      norms[3] = norms[2]
      norms[2] = norms[1]
      norms[1] = norms[0]
      norms[0] = current_norm
  
      avg_norm = (norms[2] + norms[3] + norms[4]) / 3.0
  
      #Check if clicking is detected with force
      norm_drop = avg_norm - current_norm
      if(norm_drop > drop_threshold):
        textmsg("Click detected")
        click_detected=True
      else:
        sleep(0.008)
      end
    end
  
    return click_detected
  end
  ###############################################################
  # Script file used to define Robotiq functions for the Insertion node
  # Version: 0.0.2
  ###############################################################
  
  rq_ins_offset = p[0, 0, 0, 0, 0, 0]
  rq_ins_start_pose = p[0, 0, 0, 0, 0, 0]
  rq_actual_to_destination = p[0, 0, 0, 0, 0, 0]
  rq_ins_destination =p[0, 0, 0, 0, 0, 0]
  rq_ins_speed_setting = 0
  rq_rotation_not_completed = False
  rq_find_bottom_not_completed = False
  rq_spiral_not_completed = False
  
  def ins_actual_force_urcap(direction="X+"):
    axis = str_at(direction, 0)
    if (axis == "x") or (axis == "X"):
      return norm(get_applied_tcp_force(0))
    elif (axis == "y") or (axis == "Y"):
      return norm(get_applied_tcp_force(1))
    elif (axis == "z") or (axis == "Z"):
      return norm(get_applied_tcp_force(2))
    else:
      textmsg("ins_actual_force_urcap, invalid direction ", direction)
    end
  end
  
  def ins_actual_torque_urcap(direction = "Z+"):
    if (direction == "X+") or (direction == "X-") or (direction == "X"):
      return get_applied_tcp_force(3)
    elif (direction == "Y+") or (direction == "Y-") or (direction == "Y"):
      return get_applied_tcp_force(4)
    else:
      return get_applied_tcp_force(5)
    end
  
  end
  
  def square(a):
    return a*a
  end
  
  def update_servoj_node_target(target_joint_pos):
    set_servoj_node_cmd(target_joint_pos)
    sync()
  end
  
  def create_all_insertion_nodes():
    global rq_insertion_force_node_id = node_rpc_server.createnewforcenode()
    global rq_insertion_movej_node_id = node_rpc_server.createnewmovejnode()
    global rq_insertion_servoj_node_id = node_rpc_server.createnewservojnode()
    node_rpc_server.setparentid(rq_insertion_movej_node_id, rq_insertion_force_node_id)
    node_rpc_server.setparentid(rq_insertion_servoj_node_id, rq_insertion_force_node_id)
  end
  
  def get_offset_projected_in_spiral_plane(direction, current_pose, pose_ref):
    axis = str_at(direction, 0)
    axis_index = 0
    if axis == "X":
      axis_index = 0
    elif axis == "Y":
      axis_index = 1
    elif axis == "Z":
      axis_index = 2
    else:
      textmsg("get_offset_projected_in_spiral_plane, invalid direction ", direction)
    end
  
    pose_offset = pose_trans( pose_inv(pose_ref), current_pose ) # current_pose and pose_ref should have the same orientations.
                                                                 # pose_offset is returned expressed in pose_ref frame
  
    pose_offset[axis_index] = 0 # valeur en direction mise a zero
    pose_offset[3] = 0 # valeur en Rx mise a zero
    pose_offset[4] = 0 # valeur en Ry mise a zero
    pose_offset[5] = 0 # valeur en Rz mise a zero
  
    return pose_offset
  end
  
  def update_spiral_offset(direction, spiral_initial_pose, spiral_initial_pose_offset, spiral_initial_pose_offset_name):
    pos_diff_tcp = get_offset_projected_in_spiral_plane(direction, get_actual_tcp_pose(), spiral_initial_pose)
    spiral_initial_pose_offset = interpolate_pose(spiral_initial_pose_offset, pos_diff_tcp, 0.35)
    storevar.setvariable(spiral_initial_pose_offset_name, spiral_initial_pose_offset)
  end
  
  def determine_max_spiral_radius_from_actual_position(direction, spiral_initial_pose, max_radius):
      dist_to_initial_pose = norm( get_offset_projected_in_spiral_plane(direction, get_actual_tcp_pose(), spiral_initial_pose))
      if (max_radius > dist_to_initial_pose):
        new_max_radius = max_radius - dist_to_initial_pose
      else:
        new_max_radius = 0
      end
  
      return new_max_radius
  end
  
  def insertion_compliant_move_urcap(axis = "Z",
                                     direction_sign = 1,
                                     compliant_insert_force_threshold = 20,
                                     speed = 0.04,
                                     feature = 1,
                                     max_position_deviation = 0.1):
    feature_base = 0
    feature_tool = 1
  
    if axis == "X":
      axis_index = 0
    elif axis == "Y":
      axis_index = 1
    elif axis == "Z":
      axis_index = 2
    else:
      textmsg("insertion_compliant_move_urcap, invalid direction ", axis)
    end
  
    current_pose = get_actual_tcp_pose()
    insertion_offset = p[0,0,0,0,0,0]
    rq_actual_to_destination = pose_trans(pose_inv(current_pose), rq_ins_destination)
    insertion_offset[axis_index] = rq_actual_to_destination[axis_index]
    insertion_pose = pose_trans(current_pose, insertion_offset)
    distance = point_dist(current_pose, insertion_pose)
    number_of_steps = floor( distance / (speed * get_steptime()) ) + 1
    alpha_step  = 1.0 / number_of_steps
  
    # initialize forcenode
    node_execution_thread = initialise_force_node(position_controlled_direction = axis_index,
                                                  feature = feature_tool,
                                                  max_position_deviation = max_position_deviation)
  
    alpha = 0.0
    surface_found = False
    while (alpha <= 1.0) and (not surface_found):
      alpha = alpha + alpha_step
      interpolated_pose = interpolate_pose(current_pose, insertion_pose, alpha)
      q0 = get_inverse_kin(interpolated_pose) # define waypoint target
      update_servoj_node_target(q0)
      force = 0
      if feature == feature_base:
        force = get_applied_base_force(axis_index)
      elif feature == feature_tool:
        force = get_applied_tcp_force(axis_index)
      end
      if (direction_sign * force) >= compliant_insert_force_threshold:
        surface_found = True
      end
    end
  
    final_pos_reached = (alpha >= 1)
  
    kill_thread( node_execution_thread )
  
    return final_pos_reached
  end # insertion_compliant_move_urcap
  
  def insert_spiral_find_hole(axis = "Z", direction_sign = 1,
                              stop_force_threshold = 3,
                              max_radius = 0.005,
                              radius_incr_per_turn = 0.0003,
                              peck_mode = False,
                              tangential_speed = 0.005):
  
    if (stop_force_threshold < 0) or (stop_force_threshold > 40):
      popup("stop_force_threshold parameter in Newton must be between 0 and 40 Newtons","ERROR rq_insert_spiral_urcap")
      halt
    end
    if (max_radius < 0) or (max_radius > 0.05):
      popup("max_radius parameter must be between 0 mm and 50 mm","ERROR rq_insert_spiral_urcap")
      halt
    end
    if (radius_incr_per_turn < 0.00001) or (radius_incr_per_turn > 0.005):
      popup("radius_incr_per_turn parameter in mm must be between 0.01 mm and 5 mm","ERROR rq_insert_spiral_urcap")
      halt
    end
  
    rq_spiral_not_completed = False
  
    ins_x = 0
    ins_y = 0
    ins_z = 0
    ins_pose = p[0, 0, 0, 0, 0, 0]
    ins_current_pos = p[0, 0, 0, 0, 0, 0]
    ins_actual_angle = 0
    ins_search_result = False
    ins_radius_offset = 0
    ins_PI = 3.14159
    radius_inc_per_rad = radius_incr_per_turn / (2*ins_PI)
    ins_actual_radius = 0.0001  #Start radius
    ins_desired_arc_length = tangential_speed * rq_controller_time_step
  
    sync()
    #Find the bore of the part
    ins_current_pos = get_actual_tcp_pose()
    sync()
  
    # if axis == "Z"
    search_axis = 2
    other_axis_A = 0
    other_axis_B = 1
    if (axis == "X"):
      search_axis = 0
      other_axis_A = 1
      other_axis_B = 2
    elif (axis == "Y"):
      search_axis = 1
      other_axis_A = 2
      other_axis_B = 0
    end
  
    #********************************************************************************************************************
    #Spiral Search using any Axis
    #********************************************************************************************************************
    while ((ins_actual_radius <= max_radius) and (ins_actual_force_urcap(axis) >= stop_force_threshold)):
      if peck_mode:
        #Fragile mode, the robot rises between each new point
        #Retreat from position
        ins_pose[search_axis] = -0.002 * direction_sign
        next_tcp_pose = pose_trans(ins_current_pos,ins_pose)
        movej(next_tcp_pose)
        sleep(0.1)
        #Rotate
        ins_desired_arc_length = 0.0005
        delta_angle = ins_desired_arc_length / ins_actual_radius #small angle approximation
        ins_actual_angle = ins_actual_angle + delta_angle
  
        ins_pose[other_axis_A] = cos( ins_actual_angle ) * ins_actual_radius
        ins_pose[other_axis_B] = sin( ins_actual_angle ) * ins_actual_radius
  
        ins_actual_radius = ins_actual_angle * radius_inc_per_rad + ins_radius_offset
        next_tcp_pose = pose_trans(ins_current_pos, ins_pose)
        movej(next_tcp_pose)
        sleep(0.1)
        #Re-establish contact with the part
        ins_pose[search_axis] = 0.0005 * direction_sign
        next_tcp_pose = pose_trans(ins_current_pos, ins_pose)
        movel(next_tcp_pose, a=0.6, v=rq_ins_speed_setting)
        sleep(0.2)
      else:
        #standard mode: the Spiral_Search function will maintain contact between both mating parts at all times
        ins_pose[other_axis_A] = cos( ins_actual_angle ) * ins_actual_radius
        ins_pose[other_axis_B] = sin( ins_actual_angle ) * ins_actual_radius
  
        delta_angle = ins_desired_arc_length / ins_actual_radius
        ins_actual_angle = ins_actual_angle + delta_angle
        ins_actual_radius = ins_actual_angle * radius_inc_per_rad + ins_radius_offset
        next_tcp_pose = pose_trans(ins_current_pos,ins_pose)
        next_joint_pos = get_inverse_kin(next_tcp_pose)
        servoj(next_joint_pos, 0.1, 0.1, rq_controller_time_step, 0.05, 500)
      end
    end # while loop
    if (ins_actual_radius <= max_radius ):
      ins_search_result = True
    else:
      ins_search_result = False
      rq_spiral_not_completed = True
    end
    stopj(2)
    return ins_search_result
  
  end # insert_spiral_find_hole
  
  ####################  SPIRAL #############################
  def rq_insert_spiral_urcap(direction = "Z",
                             stop_force_threshold = 3,
                             max_radius = 0.005,
                             radius_incr = 0.0003,
                             peck_mode = False,
                             tangential_speed = 0.005,
                             compliant_insert_force_threshold = 10,
                             spiral_initial_pose_offset_name = "defaultname",
                             intelligent_approach_enabled = False):
  
    max_radius = max_radius / 1000 #TODO: change unit to meters and remove this line
    radius_incr = radius_incr / 1000 #TODO: change unit to meters and remove this line
  
    if (rq_insertion_force_node_id == -1):
      create_all_insertion_nodes()
    end
  
    hole_found = False
    spiral_bottom_target_reached = False
    number_of_failed_spiral_tries = 0
    number_of_spiral_tries_max = 5
    max_position_deviation = max_radius
  
    # define the direction sign from rq_ins_destination
    current_pose = get_actual_tcp_pose()
    rq_actual_to_destination = pose_trans(pose_inv(current_pose), rq_ins_destination)
    axis = str_at(direction, 0)
    direction_sign = 1
    direction = str_cat(axis,"+")
    if axis == "X":
      axis_index = 0
    elif axis == "Y":
      axis_index = 1
    elif axis == "Z":
      axis_index = 2
    else:
      textmsg("spiral insert, invalid direction ", direction)
    end
    if (rq_actual_to_destination[axis_index] < 0):
      direction_sign = -1
      direction = str_cat(axis,"-")
    end
  
    # linearsearch param
    lin_search_stop_force_threshold = compliant_insert_force_threshold
    spiral_initial_pose = get_actual_tcp_pose()
    if intelligent_approach_enabled:
      #adjust position using previous succesfull insertion final position
      spiral_initial_pose_offset = storevar.getvariable(spiral_initial_pose_offset_name, p[0,0,0,0,0,0])
      spiral_initial_pose_refined = pose_trans(spiral_initial_pose, spiral_initial_pose_offset)
      movel(spiral_initial_pose_refined, a = 0.1, v = 0.01)
      sleep(0.01)
    end
    while ( (spiral_bottom_target_reached == False) and (number_of_failed_spiral_tries < number_of_spiral_tries_max) ):
      rq_actual_to_destination = pose_trans(pose_inv(get_actual_tcp_pose()), rq_ins_destination)
      max_distance = norm( rq_actual_to_destination[axis_index] )
      contact_initiated = rq_linear_search_urcap(direction, lin_search_stop_force_threshold, tangential_speed, max_distance, 1)
      if contact_initiated:
        new_max_radius = determine_max_spiral_radius_from_actual_position(direction, spiral_initial_pose, max_radius)
        hole_found = insert_spiral_find_hole(axis, direction_sign, stop_force_threshold, new_max_radius, radius_incr, peck_mode, tangential_speed)
        if (hole_found == True): # if hole is found, try to insert
          max_force_control_position_deviation = determine_max_spiral_radius_from_actual_position(direction, spiral_initial_pose, max_radius)
          spiral_bottom_target_reached = insertion_compliant_move_urcap(axis, direction_sign, compliant_insert_force_threshold, tangential_speed, 1, max_force_control_position_deviation)
          if spiral_bottom_target_reached:
            if intelligent_approach_enabled:
              update_spiral_offset(direction, spiral_initial_pose, spiral_initial_pose_offset, spiral_initial_pose_offset_name) # update actual hole position.
            end
          else:
            textmsg("Insertion spiral: could not reach hole bottom")
          end
        else:
          textmsg("Insertion error: hole was not found after contact")
          break
        end
      else: # linear_search reached the teach position without contact
          spiral_bottom_target_reached = True
      end # if contact_initiated
      number_of_failed_spiral_tries = number_of_failed_spiral_tries + 1
    end # while
    return (not spiral_bottom_target_reached)
  end # rq_insert_spiral_urcap
  
  def insertion_finish_move_urcap(direction = "Z+"):
    insertion_offset = p[0,0,0,0,0,0]
    current_pose = get_actual_tcp_pose()
    rq_actual_to_destination = pose_trans(pose_inv(current_pose), rq_ins_destination)
    axis = str_at(direction, 0)
    if axis == "X":
      insertion_offset = p[rq_actual_to_destination[0],0,0,0,0,0]
    elif axis == "Y":
      insertion_offset = p[0,rq_actual_to_destination[1],0,0,0,0]
    elif axis == "Z":
      insertion_offset = p[0,0,rq_actual_to_destination[2],0,0,0]
    else:
      textmsg("insertion_finish_move_urcap, invalid direction ", direction)
    end
    insertion_pose = pose_trans(current_pose, insertion_offset)
    movel(insertion_pose, a=0.05, v=rq_ins_speed_setting)
  end
  
  def rq_xor(a, b):
    return (a and not(b)) or (not(a) and b)
  end
  
  def rq_adapt_force_control_to_direction(position_controlled_direction = 2, feature = 1, max_position_deviation = 0.1):
    force_control_enabled_vector = [True, True, True, False, False, False]
    force_control_enabled_vector[position_controlled_direction] = False
    targetForce = [0, 0, 0, 0, 0, 0]
    max_negative_deviation_vector = [-max_position_deviation, -max_position_deviation, -max_position_deviation, 0, 0, 0]
    max_positive_deviation_vector = [max_position_deviation, max_position_deviation, max_position_deviation, 0, 0, 0]
    max_negative_deviation_vector[position_controlled_direction] = 0
    max_positive_deviation_vector[position_controlled_direction] = 0
    adaptiveStiffness = True
    setup_force_node_on_server(rq_insertion_force_node_id,
                               feature, targetForce,
                               force_control_enabled_vector,
                               max_negative_deviation_vector,
                               max_positive_deviation_vector,
                               adaptiveStiffness)
  end
  
  def initialise_force_node(position_controlled_direction = 2, feature = 1, max_position_deviation = 0.1):
    movej(get_actual_joint_positions()) # This moveJ is used to prevent "another thread is already controlling the robot error".
    rq_adapt_force_control_to_direction(position_controlled_direction = position_controlled_direction,
                                        feature = 1,
                                        max_position_deviation = max_position_deviation)
    set_servoj_node_cmd(get_actual_joint_positions())
    reset_node_executor()
    active_and_reset_node(rq_insertion_force_node_id)
    active_and_reset_node(rq_insertion_servoj_node_id)
    node_execution_thread = run execute_node_thread()
    return node_execution_thread
  end
  
  ####################  ROTATIONAL #############################
  def rq_insert_rotation_urcap(positive_rotation_desired = True,
                               direction="Z",
                               speed = 0.004,
                               force_threshold = 10,
                               rotation_speed = 5,
                               max_angle_deg = 360,
                               peck_mode = False,
                               max_rotation_torque=1):
  
    speed = speed / 1000 # TODO: change speed input units to meters instead of mm and remove this line
    max_force_control_position_deviation = 0.002 # TODO: add a parameter for this in the interface
    max_torque_reached_counter_fail_threshold = 1/get_steptime() # try for about one second
  
    if (rq_insertion_force_node_id == -1):
        create_all_insertion_nodes()
    end
  
    # define the direction sign
    rq_actual_to_destination = pose_trans(pose_inv(get_actual_tcp_pose()), rq_ins_destination)
    axis = str_at(direction, 0)
    direction_sign = 1
    direction = str_cat(axis,"+")
    if axis == "X":
      rq_ins_offset = p[rq_actual_to_destination[0], 0, 0, 0, 0, 0]
      rot_axe = 3
      axis_index = 0
    elif axis == "Y":
      rq_ins_offset = p[0, rq_actual_to_destination[1], 0, 0, 0, 0]
      rot_axe = 4
      axis_index = 1
    elif axis == "Z":
      rq_ins_offset = p[0, 0, rq_actual_to_destination[2], 0, 0, 0]
      rot_axe = 5
      axis_index = 2
    else:
      textmsg("insertion: invalid direction ", direction)
    end
    if (rq_actual_to_destination[axis_index] < 0):
      direction_sign = -1
      direction = str_cat(axis,"-")
      positive_rotation_desired = not positive_rotation_desired
    end
  
    distance_to_destination = norm( rq_actual_to_destination[axis_index] )
  
    contact_with_piece_initiated = rq_linear_search_urcap(direction, force_threshold, speed, distance_to_destination, feature = 1)
  
    if( contact_with_piece_initiated ):
  
      # verify validity of user inputs
      if ((rotation_speed <= 0) or (rotation_speed > 60)):
        popup("rotation speed parameter in degrees / second must be between 0.01 and 60","ERROR rq_insert_rotation_urcap")
        halt
      elif ((max_rotation_torque < 0.01) or (max_rotation_torque > 15)):
        popup("max_rotation_torque parameter in Newton-meter must be between 0.01 and 15","ERROR rq_insert_rotation_urcap")
        halt
      elif ((max_angle_deg <= 1) or (max_angle_deg > 360)):
        popup("max angle parameter in degree must be between 1 and 360","ERROR rq_insert_rotation_urcap")
        halt
      end
  
      # initialize forcenode: adapt to direction
      node_execution_thread = initialise_force_node(position_controlled_direction = axis_index,
                                                    feature = 1,
                                                    max_position_deviation = max_force_control_position_deviation)
  
      if positive_rotation_desired:
        rot_direction_sign = 1
      else:
        rot_direction_sign = -1
      end
      rq_ins_speed_setting = speed
      posrot = p[0,0,0,0,0,0]
      max_rot_angle = d2r(max_angle_deg)
      time_step_signed = rq_controller_time_step * rot_direction_sign * direction_sign
      rot_step = d2r(rotation_speed) * time_step_signed
      rot_step_5deg_per_second = d2r(5) * time_step_signed
  
      line_step = rq_ins_speed_setting * rq_controller_time_step * direction_sign
      rot_actual_angle = 0
      rot_actual_mode = 1 #1= linear, 2 = rotation
      rot_actual_distance = 0
      ins_rotation_initial_pose = get_actual_tcp_pose()
      rq_actual_to_destination = pose_trans( pose_inv(ins_rotation_initial_pose), rq_ins_destination )
      distance_to_destination = norm( rq_actual_to_destination[axis_index] )
      global rq_insertion_max_torque_reached_counter = 0
  
      if peck_mode:
        #peck mode
        positive_rotation_computed = positive_rotation_desired
        while ( (norm(rot_actual_distance) < distance_to_destination) and
                (norm(rot_actual_angle) <= max_rot_angle) and
                (rq_insertion_max_torque_reached_counter < max_torque_reached_counter_fail_threshold) ):
          is_max_torque_reached = norm(get_applied_tcp_force(rot_axe)) > max_rotation_torque
          if (ins_actual_force_urcap(direction) >= force_threshold):
            #goes up
            posrot[axis_index] = rot_actual_distance - 0.002 * direction_sign
            next_tcp_pose = pose_trans(ins_rotation_initial_pose, posrot)
            next_joint_pos = get_inverse_kin(next_tcp_pose)
            node_rpc_server.movejdefinewaypoint(rq_insertion_movej_node_id, next_joint_pos, 0.4, 0.4)
            execute_node(rq_insertion_movej_node_id, False )
            #rotate
            rot_actual_angle = compute_rotation_next_angle(rot_actual_angle, 285 * rot_step, is_max_torque_reached) # value of 285 define the peck mode "step size". determined ad oc
            posrot[rot_axe] = rot_actual_angle
            next_tcp_pose = pose_trans(ins_rotation_initial_pose, posrot)
            next_joint_pos = get_inverse_kin(next_tcp_pose)
            node_rpc_server.movejdefinewaypoint(rq_insertion_movej_node_id, next_joint_pos, 1, 1)
            execute_node(rq_insertion_movej_node_id, False )
            #go back in touch with the part
            posrot[axis_index] = rot_actual_distance
            next_tcp_pose = pose_trans(ins_rotation_initial_pose, posrot)
            next_joint_pos = get_inverse_kin(next_tcp_pose)
            node_rpc_server.movejdefinewaypoint(rq_insertion_movej_node_id, next_joint_pos, 0.4, 0.3)
            execute_node(rq_insertion_movej_node_id, False )
            sleep(0.1)
          else:
            rq_insertion_max_torque_reached_counter = 0
            rot_actual_distance = rot_actual_distance + line_step
            posrot[axis_index] = rot_actual_distance
            next_tcp_pose = pose_trans(ins_rotation_initial_pose, posrot)
            next_joint_pos = get_inverse_kin(next_tcp_pose)
            update_servoj_node_target(next_joint_pos)
            if (rq_active_node != rq_insertion_servoj_node_id):
              active_and_reset_node(rq_insertion_servoj_node_id)
            end
          end # if
        end # while
      else:
        #normal mode
        while ( (norm(rot_actual_distance) <= distance_to_destination) and
                (norm(rot_actual_angle) <= max_rot_angle) and
                (rq_insertion_max_torque_reached_counter < max_torque_reached_counter_fail_threshold) ):
          is_max_torque_reached = norm(get_applied_tcp_force(rot_axe)) > max_rotation_torque
          if ( norm(get_applied_tcp_force(axis_index)) >= force_threshold ):
            if (rot_actual_mode == 1):
              rot_actual_distance = rot_actual_distance - line_step
              posrot[axis_index] = rot_actual_distance
            end
            limited_rotation_step = limit_rotation_step_when_close_to_max_angle(rot_step, rot_step_5deg_per_second, max_rot_angle, rot_actual_angle)
            rot_actual_angle = compute_rotation_next_angle(rot_actual_angle, limited_rotation_step, is_max_torque_reached)
            posrot[rot_axe] = rot_actual_angle
            rot_actual_mode = 2
          else:
            rq_insertion_max_torque_reached_counter = 0
            rot_actual_distance = rot_actual_distance + line_step
            posrot[axis_index] = rot_actual_distance
            rot_actual_mode = 1
          end # if
          next_tcp_pose = pose_trans(ins_rotation_initial_pose, posrot)
          next_joint_pos = get_inverse_kin(next_tcp_pose)
          update_servoj_node_target(next_joint_pos)
        end # while
      end # if peck_mode
  
      kill_thread( node_execution_thread )
      stopj(2)
      rq_rotation_not_completed = ( (norm(rot_actual_angle) > max_rot_angle) or
                                    (rq_insertion_max_torque_reached_counter >= max_torque_reached_counter_fail_threshold) )
    else: # initial find_surface was unsuccessfull, assume a direct hit to target, which is a success
      rq_rotation_not_completed = False
    end # if contact_with_piece_initiated
  
    return rq_rotation_not_completed
  end # insert rotation 2
  
  def limit_rotation_step_when_close_to_max_angle(rot_step, minimal_rot_step, max_rot_angle, rot_actual_angle):
    rot_deceleration_angle_distance = d2r(3)
    rot_direction = 1
    if( rot_step < 0 ):
      rot_direction = -1
      rot_step = -1 * rot_step # get positive rot_step for calculation. Direction sign is re-introduced at the end.
    end
    angle_distance_to_max_rot_angle = max_rot_angle - norm(rot_actual_angle)
    if( (angle_distance_to_max_rot_angle < rot_deceleration_angle_distance) and (rot_step > minimal_rot_step) ):
      decelaration_slope = (rot_step - minimal_rot_step) / rot_deceleration_angle_distance
      rot_step_limited = decelaration_slope * angle_distance_to_max_rot_angle + minimal_rot_step
    else:
      rot_step_limited = rot_step
    end
    return ( rot_direction * rot_step_limited )
  end
  
  def compute_rotation_next_angle(current_angle, step, is_max_torque_reached):
  #This function compute the rotation angle for rotational insertion by
  # incrementing the current angle by the desired step size.
  # If the maximal torque is reached, the rotation goes backward to
  # return to a admissible torque. In the backward direction,
  # a smaller step size is used to prevent constant oscillation between to steps
    if (is_max_torque_reached):
        rq_insertion_max_torque_reached_counter = rq_insertion_max_torque_reached_counter + 1
        new_angle = current_angle - 0.8 * step
    else:
        new_angle = current_angle + step
    end
    return new_angle
  end
  
  def center_one_axis(axis, lin_search_stop_force_threshold, speed, max_distance, feature):
    # Initiate contact in forward direction
    contact_initiated = rq_linear_search_urcap( str_cat(axis, "+"), lin_search_stop_force_threshold, speed, max_distance, feature)
    if contact_initiated:
      forward_contact_pose = get_actual_tcp_pose()
      # Initiate contact in reverse direction
      contact_initiated = rq_linear_search_urcap(str_cat(axis, "-"), lin_search_stop_force_threshold, speed, max_distance, feature)
      if contact_initiated:
        reverse_contact_pose = get_actual_tcp_pose()
        # Go to average of contact points
        pose_center_1 = interpolate_pose(forward_contact_pose, reverse_contact_pose, 0.5)
        movel(pose_center_1, a=0.6, v=speed)
      end
    end
    return contact_initiated
  end
  
  def rq_insert_recenter_urcap(axis = "Z", max_distance = 0.1, speed = 0.005, feature = 1, lin_search_stop_force_threshold = 5):
  
    if (max_distance < 0) or (max_distance > 1):
      popup("max_distance parameter in m must be between 0 and 1","ERROR rq_insert_recenter_urcap")
      halt
    elif (speed < 0.0001) or (speed > 0.5):
      popup("max_radius parameter in mm must be between 0.0001m/s and 0.5m/s","ERROR rq_insert_recenter_urcap")
      halt
    end
  
    #--------------------------------------------------------------------------------------------------------------------
    #For insertion in the X axis
    #--------------------------------------------------------------------------------------------------------------------
    if (axis == "X"):
      recenter_axis_1 = "Y"
      recenter_axis_2 = "Z"
    #--------------------------------------------------------------------------------------------------------------------
    #For insertion in the Y axis
    #--------------------------------------------------------------------------------------------------------------------
    elif (axis == "Y"):
      recenter_axis_1 = "X"
      recenter_axis_2 = "Z"
    #--------------------------------------------------------------------------------------------------------------------
    #For insertion in the Z axis
    #--------------------------------------------------------------------------------------------------------------------
    elif (axis == "Z"):
      recenter_axis_1 = "X"
      recenter_axis_2 = "Y"
    end
  
    recenter_successfull = center_one_axis(recenter_axis_1, lin_search_stop_force_threshold, speed, max_distance, feature)
    if recenter_successfull:
      recenter_successfull = center_one_axis(recenter_axis_2, lin_search_stop_force_threshold, speed, max_distance, feature)
    end
  
    if (recenter_successfull == False):
      textmsg("rq_insert_recenter_urcap failed, could not initiate contact with piece")
    end
  
    return recenter_successfull
  end # rq_insert_recenter_urcap
  
  # ******************* MAIN of Insertion Preamble *******************
  storevar.clearall()
  global rq_insertion_force_node_id = -1
  #************************************************
  #Function:  rq_linear_search_urcap(direction="Z+", force[N] = 10, speed[m/s] = 0.004, max_distance[m] = 0.02)
  #   Find a specific force in the direction of "direction".
  #   Robot will move towards a max_distance from the current position in the tool frame
  #   Return True if the force is detected during the robot motion
  #
  #************************************************
  def rq_linear_search_urcap(direction="Z+", force_threshold = 10, speed = 0.004, max_distance = 0.02, feature = 0 ):
  
    if (max_distance > 2.0):
      popup("maximum distance parameter in meters must be between 0 and 2.0","ERROR rq_linear_search_urcap")
      halt
    elif (speed < 0.0001) or (speed > 0.15):
      popup("speed parameter in mm/s must be between 0.1 and 150","ERROR rq_linear_search_urcap")
      halt
    elif (force_threshold < 0.0) or (force_threshold > 200):
      popup("Force parameter in Newtons must be between 0 and 200","ERROR rq_linear_search_urcap")
      halt
    elif (feature != 0) and (feature != 1):
      popup("feature value should be 0 for base or 1 for tool","ERROR rq_linear_search_urcap")
      halt
    end
  
    feature_base = 0
    feature_tool = 1
    steptime = get_steptime()
    force_index = 0
  
    axis = str_at(direction, 0)
    sign = str_at(direction, 1)
  
    direction_sign = 1
    if sign == "-":
      direction_sign = -1
      max_distance = max_distance * direction_sign
    end
  
    pose_offset = p[0,0,0,0,0,0]
    if (axis == "X") or (axis == "x"):
      pose_offset = p[max_distance,0,0,0,0,0]
      force_index = 0
    elif (axis == "Y") or (axis == "y"):
      pose_offset = p[0,max_distance,0,0,0,0]
      force_index = 1
    elif (axis == "Z") or (axis == "z"):
      pose_offset = p[0,0,max_distance,0,0,0]
      force_index = 2
    else:
      popup("direction parameter must be X+, X-, Y+, Y-, Z+ or Z-","ERROR rq_linear_search_urcap")
      halt
    end
  
    pose_from = get_actual_tcp_pose()
    pose_to = pose_from
    if feature == feature_base:
      pose_to = pose_add(pose_from, pose_offset)
    elif feature == feature_tool:
      pose_to = pose_trans(pose_from, pose_offset)
    end
  
    distance = point_dist(pose_from, pose_to)
    number_pose_interpolate = floor(distance / (speed * steptime)) + 1
    delta_alpha = 1.0 / number_pose_interpolate
  
    alpha = 0.0
    local surface_found = False
  
    while (alpha <= 1.0) and (not surface_found):
      alpha = alpha + delta_alpha
      pose_interpolate = interpolate_pose(pose_from, pose_to, alpha)
      servoj(get_inverse_kin(pose_interpolate), 0.1, 0.1, steptime, 0.05, 500)
  
      force = 0
      if feature == feature_base:
        force = get_applied_base_force(force_index)
      elif feature == feature_tool:
        force = get_applied_tcp_force(force_index)
      end
  
      if (direction_sign * force) >= force_threshold:
        surface_found = True
      end
    end
  
    return surface_found
  
  end
  
    ##############################################
    # OFFSET FEATURE-RELATED VARIABLES AND METHODS
    ##############################################
    def cross_product(vector1,vector2):
      v_temp=[0,0,0]
      v_temp[0]=vector1[1]*vector2[2]-vector1[2]*vector2[1]
      v_temp[1]=vector1[2]*vector2[0]-vector1[0]*vector2[2]
      v_temp[2]=vector1[0]*vector2[1]-vector1[1]*vector2[0]
      return v_temp
    end
  
    def relocate_xyzr(init_feature, init_touch_pose, touch_pose):
      init_touch_pose_2_init_feature = pose_trans( pose_inv(init_touch_pose), init_feature)
      new_feature = pose_trans( touch_pose, init_touch_pose_2_init_feature )
  
      return new_feature
    end
  
    def relocate_orientation(touch1_init_pose, touch2_init_pose, feature_init_pose, touch1_pose, touch2_pose):
      #when relocating using 2 touch, the center of rotation is around touch point 1 (this could be changed)
  
      # initial touch2 pose in initial touch 1 pose frame:
      touch2_initial_pose_in_touch1_initial_pose_frame = pose_trans(pose_inv(touch1_init_pose), touch2_init_pose)
  
      # find theoric touch2_pose if no rotation
      touch2_pose_if_no_rotation = pose_trans(touch1_pose, touch2_initial_pose_in_touch1_initial_pose_frame)
  
      # vectors touch1 to touch2
      touch1_pose_to_touch2_pose = pose_trans(pose_inv(touch1_pose), touch2_pose)
      touch1_pose_to_touch2_pose_if_no_rotation = pose_trans(pose_inv(touch1_pose), touch2_pose_if_no_rotation)
  
      #angle axis calculation
      normal_vector = cross_product(touch1_pose_to_touch2_pose_if_no_rotation, touch1_pose_to_touch2_pose)
      normal_vector_norm = norm(normal_vector)
      if (normal_vector_norm > 10e-6):
        rotation_angle_rad = asin( normal_vector_norm / (norm(touch1_pose_to_touch2_pose_if_no_rotation) * norm(touch1_pose_to_touch2_pose) ) )
        normal_vector_to_angle_axis_multiply_norm_factor = rotation_angle_rad / normal_vector_norm
        angle_axis = [normal_vector[0] * normal_vector_to_angle_axis_multiply_norm_factor, normal_vector[1] * normal_vector_to_angle_axis_multiply_norm_factor, normal_vector[2] * normal_vector_to_angle_axis_multiply_norm_factor]
        rotation_offset_pose = p[0, 0, 0, angle_axis[0], angle_axis[1], angle_axis[2]]
  
        #rotate touch1 pose using touch2 information
        touch1_pose_rotated = pose_trans(touch1_pose, rotation_offset_pose)
      else:
        touch1_pose_rotated = touch1_pose
      end
  
      # relocate the feature using touch1_rotated_pose
      return relocate_xyzr(feature_init_pose, touch1_init_pose, touch1_pose_rotated)
    end
  
    def relocate_1_touch(touch_init_pose, touch_pose, feature_init_pose, feature_actual_pose):
      touch_initial_pose_in_initial_feature_frame = pose_trans(pose_inv(feature_init_pose), touch_init_pose)
      touch_actual_pose_in_actual_feature_frame = pose_trans(pose_inv(feature_actual_pose), touch_pose)
  
      # difference between touch poses in their respective feature frame
      touch_pose_offset = pose_sub(touch_actual_pose_in_actual_feature_frame, touch_initial_pose_in_initial_feature_frame)
  
      # remove all rotation from offset
      touch_pose_offset[3] = 0
      touch_pose_offset[4] = 0
      touch_pose_offset[5] = 0
  
      # apply pose offset to actual feature
      return pose_trans(feature_actual_pose, touch_pose_offset)
    end
    ##############################################
    # PALLETIZER-RELATED VARIABLES AND METHODS
    ##############################################
    rq_total_box_count = 0
    rq_current_box_count = 0
    rq_pallet_one_current_box_count = 0
    rq_pallet_two_current_box_count = 0
    rq_pallet_one_current_box_count_updated = False
    rq_pallet_two_current_box_count_updated = False
    rq_is_pallet_program_started_once = False
  
    def rq_is_last_box_of_layer(box_id, end_of_layer_boxes):
      number_of_layers = length(end_of_layer_boxes)
      i = 0
      while i < number_of_layers:
        if box_id == end_of_layer_boxes[i]:
          return True
          break
        end
        i = i + 1
      end
      return False
    end
  
    def rq_is_palletOne_activated(pallet_one_current_box_count, pallet_two_current_box_count, second_pallet_activated):
      return ((pallet_one_current_box_count == 0) and (pallet_two_current_box_count == 0) and (not second_pallet_activated)) or (pallet_one_current_box_count > pallet_two_current_box_count)
    end
    global servojId = 2
  rq_collision_detection_stop()
  contactOffsetXmlRpcClient = rpc_factory("xmlrpc","http://localhost:35279")
  palletizerXmlRpcClient = rpc_factory("xmlrpc","http://localhost:41015")
  # end: URCap Installation Node
  # begin: URCap Installation Node
  #   Source: Robotiq_Grippers, 1.8.3.4198-beta, Robotiq Inc.
  #   Type: Gripper
  rq_gripper_socket_ip_address = "127.0.0.1"
  rq_gripper_socket_port = 63352
  
  rq_comm_check_fail_counter = [0, 0, 0, 0]
  
  rq_read_act = [-1, -1, -1, -1]
  rq_read_gto = [-1, -1, -1, -1]
  rq_read_for = [-1, -1, -1, -1]
  rq_read_spe = [-1, -1, -1, -1]
  rq_read_obj = [-1, -1, -1, -1]
  rq_read_sta = [-1, -1, -1, -1]
  rq_read_flt = [-1, -1, -1, -1]
  rq_read_pos = [-1, -1, -1, -1]
  rq_read_pre = [-1, -1, -1, -1]
  rq_read_lbp = [-1, -1, -1, -1]
  rq_read_lrd = [-1, -1, -1, -1]
  rq_read_lbl = [-1, -1, -1, -1]
  rq_read_lgn = [-1, -1, -1, -1]
  rq_read_msc = [-1, -1, -1, -1]
  rq_read_mod = [-1, -1, -1, -1]
  rq_read_cou = [-1, -1, -1, -1]
  rq_read_ncy = [-1, -1, -1, -1]
  rq_read_dst = [-1, -1, -1, -1]
  rq_read_pco = [-1, -1, -1, -1]
  
  rq_string_initial_value = "N/A"
  
  rq_read_snu_1 = rq_string_initial_value
  rq_read_snu_2 = rq_string_initial_value
  rq_read_snu_3 = rq_string_initial_value
  rq_read_snu_4 = rq_string_initial_value
  
  rq_read_fwv_1 = rq_string_initial_value
  rq_read_fwv_2 = rq_string_initial_value
  rq_read_fwv_3 = rq_string_initial_value
  rq_read_fwv_4 = rq_string_initial_value
  
  rq_read_ver_1 = rq_string_initial_value
  rq_read_ver_2 = rq_string_initial_value
  rq_read_ver_3 = rq_string_initial_value
  rq_read_ver_4 = rq_string_initial_value
  
  rq_read_act_req = [True, True, True, True]
  rq_read_gto_req = [True, True, True, True]
  rq_read_for_req = [True, True, True, True]
  rq_read_spe_req = [True, True, True, True]
  rq_read_obj_req = [True, True, True, True]
  rq_read_sta_req = [True, True, True, True]
  rq_read_flt_req = [True, True, True, True]
  rq_read_pos_req = [True, True, True, True]
  rq_read_pre_req = [True, True, True, True]
  rq_read_lbp_req = [True, True, True, True]
  rq_read_lrd_req = [True, True, True, True]
  rq_read_lbl_req = [True, True, True, True]
  rq_read_lgn_req = [True, True, True, True]
  rq_read_msc_req = [True, True, True, True]
  rq_read_mod_req = [True, True, True, True]
  rq_read_cou_req = [True, True, True, True]
  rq_read_ncy_req = [True, True, True, True]
  rq_read_dst_req = [True, True, True, True]
  rq_read_pco_req = [True, True, True, True]
  
  rq_read_snu_1_req = False
  rq_read_snu_2_req = False
  rq_read_snu_3_req = False
  rq_read_snu_4_req = False
  
  rq_read_fwv_1_req = False
  rq_read_fwv_2_req = False
  rq_read_fwv_3_req = False
  rq_read_fwv_4_req = False
  
  rq_read_ver_1_req = False
  rq_read_ver_2_req = False
  rq_read_ver_3_req = False
  rq_read_ver_4_req = False
  
  rq_write_act_request = [False, False, False, False]
  rq_write_gto_request = [False, False, False, False]
  rq_write_atr_request = [False, False, False, False]
  rq_write_ard_request = [False, False, False, False]
  rq_write_pos_request = [False, False, False, False]
  rq_write_lbp_request = [False, False, False, False]
  rq_write_lrd_request = [False, False, False, False]
  rq_write_lbl_request = [False, False, False, False]
  rq_write_lgn_request = [False, False, False, False]
  rq_write_msc_request = [False, False, False, False]
  rq_write_mod_request = [False, False, False, False]
  
  rq_write_act = [-1, -1, -1, -1]
  rq_write_gto = [-1, -1, -1, -1]
  rq_write_atr = [-1, -1, -1, -1]
  rq_write_ard = [-1, -1, -1, -1]
  rq_write_for = [-1, -1, -1, -1]
  rq_write_spe = [-1, -1, -1, -1]
  rq_write_pos = [-1, -1, -1, -1]
  rq_write_lbp = [-1, -1, -1, -1]
  rq_write_lrd = [-1, -1, -1, -1]
  rq_write_lbl = [-1, -1, -1, -1]
  rq_write_lgn = [-1, -1, -1, -1]
  rq_write_msc = [-1, -1, -1, -1]
  rq_write_mod = [-1, -1, -1, -1]
  
  rq_write_act_previous = rq_write_act
  rq_write_gto_previous = rq_write_gto
  rq_write_atr_previous = rq_write_atr
  rq_write_ard_previous = rq_write_ard
  rq_write_for_previous = rq_write_for
  rq_write_spe_previous = rq_write_spe
  rq_write_pos_previous = rq_write_pos
  rq_write_lbp_previous = rq_write_lbp
  rq_write_lrd_previous = rq_write_lrd
  rq_write_lbl_previous = rq_write_lbl
  rq_write_lgn_previous = rq_write_lgn
  rq_write_msc_previous = rq_write_msc
  rq_write_mod_previous = rq_write_mod
  
  gripper_connected = [False, False, False, False]
  gripper_socket_open = [False, False, False, False]
  rq_comm_clear_socket_buffer_enabled = [True, True, True, True]
  rq_comm_check_counter = 0
  rq_gripper_communication_thread_started = False
  
  thread rq_gripper_communication():
      rq_comm_read_constants()
      rq_comm_read_variables()
      rq_comm_initialize_write_values()
  
      while(True):
          rq_comm_clear_socket_buffer()
          rq_comm_check()
          rq_comm_read_variables()
          rq_comm_write_variables()
  
          rq_gripper_communication_thread_started = True
          sync()
      end
  end
  
  def rq_socket_to_index(gripper_socket="1"):
      # Patch in case gripper_socket is an integer
      gripper_socket_string = str_cat("", gripper_socket)
  
      if(gripper_socket_string == "1"):
          return 0
      elif(gripper_socket_string == "2"):
          return 1
      elif(gripper_socket_string == "3"):
          return 2
      elif(gripper_socket_string == "4"):
          return 3
      end
      return 0
  end
  
  def rq_index_to_socket(index=0):
      if(index == 0):
          return "1"
      elif(index == 1):
          return "2"
      elif(index == 2):
          return "3"
      elif(index == 3):
          return "4"
      end
      return "1"
  end
  
  def rq_comm_check():
      index = 0
      rq_comm_check_fail_counter_max = 99999
  
      if(rq_comm_check_counter < 50):
          rq_comm_check_counter = rq_comm_check_counter + 1
      else:
          rq_comm_check_counter = 0
  
          while(index <= 3):
              socket = rq_index_to_socket(index)
  
              if(gripper_connected[index]):
                  # Patch in case gripper_socket is an integer
                  gripper_socket_string = str_cat("", socket)
  
                  sid_list = rq_get_sid(socket)
                  is_gripper_in_sid_list = rq_is_gripper_in_sid_list(gripper_socket_string, sid_list)
  
                  if(is_gripper_in_sid_list):
                      rq_comm_check_fail_counter[index] = 0
                  else:
                      rq_comm_check_fail_counter[index] = rq_comm_check_fail_counter[index] + 1
                  end
  
                  if(rq_comm_check_fail_counter[index] > rq_comm_check_fail_counter_max):
                      message = str_cat("Communication lost with Robotiq's Gripper Slave ID ", gripper_socket_string)
                      popup(message, "Communication Error", False, True, True)
                  end
              end
              index = index + 1
          end
      end
  end
  
  def rq_init_comm_if_connected(gripper_sid=9, gripper_socket="1"):
      if(not is_gripper_socket_open(gripper_socket)):
        open_gripper_socket(gripper_socket)
      end
  
      socket_sid_set = rq_set_sid(gripper_sid, gripper_socket)
  
      if(socket_sid_set):
          # Patch in case gripper_socket is an integer
          gripper_socket_string = str_cat("", gripper_socket)
  
          sid_list = rq_get_sid(gripper_socket)
          is_gripper_in_sid_list = rq_is_gripper_in_sid_list(gripper_socket_string, sid_list)
  
          if(is_gripper_in_sid_list):
              rq_set_gripper_connected(gripper_socket_string)
              return True
          end
      end
  
      return False
  end
  
  def open_gripper_socket(gripper_socket="1"):
      is_open = socket_open(rq_gripper_socket_ip_address, rq_gripper_socket_port, gripper_socket)
      set_gripper_socket_open(gripper_socket, is_open)
  end
  
  def is_gripper_socket_open(gripper_socket="1"):
      return gripper_socket_open[rq_socket_to_index(gripper_socket)]
  end
  
  def set_gripper_socket_open(gripper_socket, is_open):
      gripper_socket_open[rq_socket_to_index(gripper_socket)] = is_open
  end
  
  def rq_set_gripper_connected(gripper_id="1"):
      gripper_connected[rq_socket_to_index(gripper_id)] = True
  end
  
  def rq_is_gripper_connected(gripper_id="1"):
      return gripper_connected[rq_socket_to_index(gripper_id)]
  end
  
  def rq_set_sid(gripper_sid=9, gripper_socket="1"):
      socket_set_var("SID", gripper_sid,  gripper_socket)
      ack = socket_read_byte_list(3, gripper_socket)
      return is_ack(ack)
  end
  
  def rq_get_sid(gripper_socket="1"):
      socket_send_string("GET SID", gripper_socket)
      sid_list = socket_read_byte_list(17, gripper_socket)
      return sid_list
  end
  
  def rq_wait_for_gripper_connected():
      gripper_socket = "gripper_conn_socket"
      socket_open(rq_gripper_socket_ip_address, rq_gripper_socket_port, gripper_socket)
  
      remainingRetries = 2000
      sid_list = rq_get_sid(gripper_socket)
      gripper_is_connected = rq_is_any_gripper_connected(sid_list)
  
      while(not gripper_is_connected and remainingRetries > 0):
          remainingRetries = remainingRetries - 1
          sid_list = rq_get_sid(gripper_socket)
          gripper_is_connected = rq_is_any_gripper_connected(sid_list)
      end
  
      socket_close(gripper_socket)
  end
  
  def rq_is_any_gripper_connected(sid_list):
      is_gripper_1_connected = rq_is_gripper1_in_sid_list(sid_list)
      is_gripper_2_connected = rq_is_gripper2_in_sid_list(sid_list)
      is_gripper_3_connected = rq_is_gripper3_in_sid_list(sid_list)
      is_gripper_4_connected = rq_is_gripper4_in_sid_list(sid_list)
  
      return is_gripper_1_connected or is_gripper_2_connected or is_gripper_3_connected or is_gripper_4_connected
  end
  
  def rq_is_gripper_ascii_in_sid_list(gripper_ascii_sid, sid_list):
      sid_list_length = sid_list[0]
      sid_list_empty_length = 2
  
      if (sid_list_length <= sid_list_empty_length):
          return False
      end
  
      sid1 = sid_list[2]
      sid2 = sid_list[5]
      sid3 = sid_list[8]
      sid4 = sid_list[11]
  
      return sid1 == gripper_ascii_sid or sid2 == gripper_ascii_sid or sid3 == gripper_ascii_sid or sid4 == gripper_ascii_sid
  end
  
  def rq_is_gripper_in_sid_list(gripper_socket_string, sid_list):
      if(gripper_socket_string == "1"):
          return rq_is_gripper1_in_sid_list(sid_list)
      elif(gripper_socket_string == "2"):
          return rq_is_gripper2_in_sid_list(sid_list)
      elif(gripper_socket_string == "3"):
          return rq_is_gripper3_in_sid_list(sid_list)
      elif(gripper_socket_string == "4"):
          return rq_is_gripper4_in_sid_list(sid_list)
      end
      return False
  end
  
  def rq_is_gripper1_in_sid_list(sid_list):
      gripper_1_sid_ascii = 57
      return rq_is_gripper_ascii_in_sid_list(gripper_1_sid_ascii, sid_list)
  end
  
  def rq_is_gripper2_in_sid_list(sid_list):
      gripper_2_sid_ascii = 50
      return rq_is_gripper_ascii_in_sid_list(gripper_2_sid_ascii, sid_list)
  end
  
  def rq_is_gripper3_in_sid_list(sid_list):
      gripper_3_sid_ascii = 51
      return rq_is_gripper_ascii_in_sid_list(gripper_3_sid_ascii, sid_list)
  end
  
  def rq_is_gripper4_in_sid_list(sid_list):
      gripper_4_sid_ascii = 52
      return rq_is_gripper_ascii_in_sid_list(gripper_4_sid_ascii, sid_list)
  end
  
  def rq_comm_clear_socket_buffer():
      index = 0
  
      while(index <= 3):
          socket = rq_index_to_socket(index)
  
          if(gripper_connected[index] and rq_comm_clear_socket_buffer_enabled[index]):
              byte_in_buffer = socket_read_byte_list(1, socket, 0.002)
              while(byte_in_buffer[0] >= 1):
                  byte_in_buffer = socket_read_byte_list(1, socket, 0.002)
              end
              rq_comm_clear_socket_buffer_enabled[index] = False
          end
          index = index + 1
      end
  end
  
  def rq_comm_initialize_write_values():
      index = 0
  
      while(index <= 3):
          socket = rq_index_to_socket(index)
  
          if(gripper_connected[index]):
  
              if(rq_write_act[index] == -1 and rq_read_act[index] != -1):
                  rq_write_act[index] = rq_read_act[index]
                  rq_write_act_previous[index] = rq_read_act[index]
              elif(rq_write_act_previous[index] == -1 and rq_read_act[index] != -1):
                  rq_write_act_previous[index] = rq_read_act[index]
              end
  
              if(rq_write_gto[index] == -1 and rq_read_gto[index] != -1):
                  rq_write_gto[index] = rq_read_gto[index]
                  rq_write_gto_previous[index] = rq_read_gto[index]
              elif(rq_write_gto_previous[index] == -1 and rq_read_gto[index] != -1):
                  rq_write_gto_previous[index] = rq_read_gto[index]
              end
  
              if(rq_write_for[index] == -1 and rq_read_for[index] != -1):
                  rq_write_for[index] = rq_read_for[index]
                  rq_write_for_previous[index] = rq_read_for[index]
              elif(rq_write_for_previous[index] == -1 and rq_read_for[index] != -1):
                  rq_write_for_previous[index] = rq_read_for[index]
              end
  
              if(rq_write_spe[index] == -1 and rq_read_spe[index] != -1):
                  rq_write_spe[index] = rq_read_spe[index]
                  rq_write_spe_previous[index] = rq_read_spe[index]
              elif(rq_write_spe_previous[index] == -1 and rq_read_spe[index] != -1):
                  rq_write_spe_previous[index] = rq_read_spe[index]
              end
  
              if(rq_write_pos[index] == -1 and rq_read_pos[index] != -1):
                  rq_write_pos[index] = rq_read_pos[index]
                  rq_write_pos_previous[index] = rq_read_pos[index]
              elif(rq_write_pos_previous[index] == -1 and rq_read_pos[index] != -1):
                  rq_write_pos_previous[index] = rq_read_pos[index]
              end
  
              if(rq_write_lbp[index] == -1 and rq_read_lbp[index] != -1):
                  rq_write_lbp[index] = rq_read_lbp[index]
                  rq_write_lbp_previous[index] = rq_read_lbp[index]
              elif(rq_write_lbp_previous[index] == -1 and rq_read_lbp[index] != -1):
                  rq_write_lbp_previous[index] = rq_read_lbp[index]
              end
  
              if(rq_write_lrd[index] == -1 and rq_read_lrd[index] != -1):
                  rq_write_lrd[index] = rq_read_lrd[index]
                  rq_write_lrd_previous[index] = rq_read_lrd[index]
              elif(rq_write_lrd_previous[index] == -1 and rq_read_lrd[index] != -1):
                  rq_write_lrd_previous[index] = rq_read_lrd[index]
              end
  
              if(rq_write_lbl[index] == -1 and rq_read_lbl[index] != -1):
                  rq_write_lbl[index] = rq_read_lbl[index]
                  rq_write_lbl_previous[index] = rq_read_lbl[index]
              elif(rq_write_lbl_previous[index] == -1 and rq_read_lbl[index] != -1):
                  rq_write_lbl_previous[index] = rq_read_lbl[index]
              end
  
              if(rq_write_lgn[index] == -1 and rq_read_lgn[index] != -1):
                  rq_write_lgn[index] = rq_read_lgn[index]
                  rq_write_lgn_previous[index] = rq_read_lgn[index]
              elif(rq_write_lgn_previous[index] == -1 and rq_read_lgn[index] != -1):
                  rq_write_lgn_previous[index] = rq_read_lgn[index]
              end
  
              if(rq_write_msc[index] == -1 and rq_read_msc[index] != -1):
                  rq_write_msc[index] = rq_read_msc[index]
                  rq_write_msc_previous[index] = rq_read_msc[index]
              elif(rq_write_msc_previous[index] == -1 and rq_read_msc[index] != -1):
                  rq_write_msc_previous[index] = rq_read_msc[index]
              end
  
              if(rq_write_mod[index] == -1 and rq_read_mod[index] != -1):
                  rq_write_mod[index] = rq_read_mod[index]
                  rq_write_mod_previous[index] = rq_read_mod[index]
              elif(rq_write_mod_previous[index] == -1 and rq_read_mod[index] != -1):
                  rq_write_mod_previous[index] = rq_read_mod[index]
              end
  
          end
          index = index + 1
      end
  end
  
  def rq_comm_set_var(var, value=0, gripper_socket="1"):
      socket_set_var(var, value, gripper_socket)
      return socket_read_byte_list(3, gripper_socket)
  end
  
  def rq_comm_set_pos_spe_for(pos=0, speed=0, force=0, gripper_socket="1"):
      socket_send_string("SET POS", gripper_socket)
      socket_send_byte(32, gripper_socket)
      socket_send_string(pos, gripper_socket)
      socket_send_byte(32, gripper_socket)
      socket_send_string("SPE", gripper_socket)
      socket_send_byte(32, gripper_socket)
      socket_send_string(speed, gripper_socket)
      socket_send_byte(32, gripper_socket)
      socket_send_string("FOR", gripper_socket)
      socket_send_byte(32, gripper_socket)
      socket_send_string(force, gripper_socket)
      socket_send_byte(10, gripper_socket)
      return socket_read_byte_list(3, gripper_socket)
  end
  
  def rq_comm_read_variables():
      index = 0
  
      while(index <= 3):
          socket = rq_index_to_socket(index)
  
          if(gripper_connected[index]):
  
              if(rq_read_act_req[index]):
                  rq_read_act[index] = socket_get_var("ACT", socket)
                  rq_read_act_req[index] = False
              end
  
              if(rq_read_gto_req[index]):
                  rq_read_gto[index] = socket_get_var("GTO", socket)
                  rq_read_gto_req[index] = False
              end
  
              if(rq_read_pre_req[index]):
                  rq_read_pre[index] = socket_get_var("PRE", socket)
                  rq_read_pre_req[index] = False
              end
  
              if(rq_read_pos_req[index]):
                  rq_read_pos[index] = socket_get_var("POS", socket)
                  rq_read_pos_req[index] = False
              end
  
              if(rq_read_spe_req[index]):
                  rq_read_spe[index] = socket_get_var("SPE", socket)
                  rq_read_spe_req[index] = False
              end
  
              if(rq_read_for_req[index]):
                  rq_read_for[index] = socket_get_var("FOR", socket)
                  rq_read_for_req[index] = False
              end
  
              if(rq_read_obj_req[index]):
                  rq_read_obj[index] = socket_get_var("OBJ", socket)
                  rq_read_obj_req[index] = False
              end
  
              if(rq_read_sta_req[index]):
                  rq_read_sta[index] = socket_get_var("STA", socket)
                  rq_read_sta_req[index] = False
              end
  
              if(rq_read_mod_req[index]):
                  rq_read_mod[index] = socket_get_var("MOD", socket)
                  rq_read_mod_req[index] = False
              end
  
              if(rq_read_flt_req[index]):
                  rq_read_flt[index] = socket_get_var("FLT",socket)
                  rq_read_flt_req[index] = False
              end
  
              if(rq_read_lbp_req[index]):
                  rq_read_lbp[index] = socket_get_var("LBP", socket)
                  rq_read_lbp_req[index] = False
              end
  
              if(rq_read_lrd_req[index]):
                  rq_read_lrd[index] = socket_get_var("LRD", socket)
                  rq_read_lrd_req[index] = False
              end
  
              if(rq_read_lbl_req[index]):
                  rq_read_lbl[index] = socket_get_var("LBL",socket)
                  rq_read_lbl_req[index] = False
              end
  
              if(rq_read_lgn_req[index]):
                  rq_read_lgn[index] = socket_get_var("LGN", socket)
                  rq_read_lgn_req[index] = False
              end
  
              if(rq_read_msc_req[index]):
                  rq_read_msc[index] = socket_get_var("MSC", socket)
                  rq_read_msc_req[index] = False
              end
  
              if(rq_read_cou_req[index]):
                  rq_read_cou[index] = socket_get_var("COU", socket)
                  rq_read_cou_req[index] = False
              end
  
              if(rq_read_ncy_req[index]):
                  rq_read_ncy[index] = socket_get_var("NCY", socket)
                  rq_read_ncy_req[index] = False
              end
  
              if(rq_read_dst_req[index]):
                  rq_read_dst[index] = socket_get_var("DST", socket)
                  rq_read_dst_req[index] = False
              end
  
              if(rq_read_pco_req[index]):
                  rq_read_pco[index] = socket_get_var("PCO", socket)
                  rq_read_pco_req[index] = False
              end
          end
          index = index + 1
      end
  end
  
  def rq_comm_read_constants():
  
      if(gripper_connected[0]):
          while(rq_read_snu_1 == rq_string_initial_value):
              socket_send_string("GET SNU", "1")
              rq_read_snu_1 = socket_read_string("1")
          end
  
          while(rq_read_fwv_1 == rq_string_initial_value):
              socket_send_string("GET FWV", "1")
              rq_read_fwv_1 = socket_read_string("1")
          end
  
          while(rq_read_ver_1 == rq_string_initial_value):
              socket_send_string("GET VER", "1")
              rq_read_ver_1 = socket_read_string("1")
          end
      end
  
      if(gripper_connected[1]):
          while(rq_read_snu_2 == rq_string_initial_value):
              socket_send_string("GET SNU", "2")
              rq_read_snu_2 = socket_read_string("2")
          end
  
          while(rq_read_fwv_2 == rq_string_initial_value):
              socket_send_string("GET FWV", "2")
              rq_read_fwv_2 = socket_read_string("2")
          end
  
          while(rq_read_ver_2 == rq_string_initial_value):
              socket_send_string("GET VER", "2")
              rq_read_ver_2 = socket_read_string("2")
          end
      end
  
      if(gripper_connected[2]):
          while(rq_read_snu_3 == rq_string_initial_value):
              socket_send_string("GET SNU", "3")
              rq_read_snu_3 = socket_read_string("3")
          end
  
          while(rq_read_fwv_3 == rq_string_initial_value):
              socket_send_string("GET FWV", "3")
              rq_read_fwv_3 = socket_read_string("3")
          end
  
          while(rq_read_ver_3 == rq_string_initial_value):
              socket_send_string("GET VER", "3")
              rq_read_ver_3 = socket_read_string("3")
          end
      end
  
      if(gripper_connected[3]):
          while(rq_read_snu_4 == rq_string_initial_value):
              socket_send_string("GET SNU", "4")
              rq_read_snu_4 = socket_read_string("4")
          end
  
          while(rq_read_fwv_4 == rq_string_initial_value):
              socket_send_string("GET FWV", "4")
              rq_read_fwv_4 = socket_read_string("4")
          end
  
          while(rq_read_ver_4 == rq_string_initial_value):
              socket_send_string("GET VER", "4")
              rq_read_ver_4 = socket_read_string("4")
          end
      end
  end
  
  def rq_comm_write_variables():
      index = 0
  
      while(index <= 3):
          socket = rq_index_to_socket(index)
  
          if(gripper_connected[index]):
  
              if(rq_write_act_request[index]):
                  if(is_ack(rq_comm_set_var("ACT", rq_write_act[index], socket))):
                      rq_write_act_previous[index] = rq_write_act[index]
                      rq_write_act_request[index] = False
                  end
              end
  
              if(rq_write_gto_request[index]):
                  if(is_ack(rq_comm_set_var("GTO", rq_write_gto[index], socket))):
                      rq_write_gto_previous[index] = rq_write_gto[index]
                      rq_write_gto_request[index] = False
                  end
              end
  
              if(rq_write_atr_request[index]):
                  if(is_ack(rq_comm_set_var("ATR", rq_write_atr[index], socket))):
                      rq_write_atr_previous[index] = rq_write_atr[index]
                      rq_write_atr_request[index] = False
                  end
              end
  
              if(rq_write_ard_request[index]):
                  if(is_ack(rq_comm_set_var("ARD", rq_write_ard[index], socket))):
                      rq_write_ard_previous[index] = rq_write_ard[index]
                      rq_write_ard_request[index] = False
                  end
              end
  
              if(rq_write_pos_request[index]):
                  if(is_ack(rq_comm_set_pos_spe_for(rq_write_pos[index], rq_write_spe[index], rq_write_for[index], socket))):
                      rq_write_pos_previous[index] = rq_write_pos[index]
                      rq_write_spe_previous[index] = rq_write_spe[index]
                      rq_write_for_previous[index] = rq_write_for[index]
                      rq_write_pos_request[index] = False
                  end
              end
  
              if(rq_write_lbp_request[index]):
                  if(is_ack(rq_comm_set_var("LBP", rq_write_lbp[index], socket))):
                      rq_write_lbp_previous[index] = rq_write_lbp[index]
                      rq_write_lbp_request[index] = False
                  end
              end
  
              if(rq_write_lrd_request[index]):
                  if(is_ack(rq_comm_set_var("LRD", rq_write_lrd[index], socket))):
                      rq_write_lrd_previous[index] = rq_write_lrd[index]
                      rq_write_lrd_request[index] = False
                  end
              end
  
              if(rq_write_lbl_request[index]):
                  if(is_ack(rq_comm_set_var("LBL", rq_write_lbl[index], socket))):
                      rq_write_lbl_previous[index] = rq_write_lbl[index]
                      rq_write_lbl_request[index] = False
                  end
              end
  
              if(rq_write_lgn_request[index]):
                  if(is_ack(rq_comm_set_var("LGN", rq_write_lgn[index], socket))):
                      rq_write_lgn_previous[index] = rq_write_lgn[index]
                      rq_write_lgn_request[index] = False
                  end
              end
  
              if(rq_write_msc_request[index]):
                  if(is_ack(rq_comm_set_var("MSC", rq_write_msc[index], socket))):
                      rq_write_msc_previous[index] = rq_write_msc[index]
                      rq_write_msc_request[index] = False
                  end
              end
  
              if(rq_write_mod_request[index]):
                  if(is_ack(rq_comm_set_var("MOD", rq_write_mod[index], socket))):
                      rq_write_mod_previous[index] = rq_write_mod[index]
                      rq_write_mod_request[index] = False
                  end
              end
          end
          index = index + 1
      end
  end
  
  def rq_activate(gripper_socket="1"):
      if (not rq_is_gripper_activated(gripper_socket)):
          rq_reset(gripper_socket)
  
          while(not rq_get_var("ACT", 1, gripper_socket) == 0 or not rq_get_var("STA", 1, gripper_socket) == 0):
              rq_reset(gripper_socket)
              sync()
          end
  
          rq_set_var("ACT",1, gripper_socket)
      end
  end
  
  def rq_activate_and_wait(gripper_socket="1"):
      if (not rq_is_gripper_activated(gripper_socket)):
          rq_activate(gripper_socket)
          sleep(1.0)
  
          while(not rq_get_var("ACT", 1, gripper_socket) == 1 or not rq_get_var("STA", 1, gripper_socket) == 3):
              sleep(0.1)
          end
  
          sleep(0.5)
      end
  end
  
  def rq_activate_all_grippers(reset=False):
      if(gripper_connected[0]):
          rq_reset_and_activate("1", reset)
      end
  
      if(gripper_connected[1]):
          rq_reset_and_activate("2", reset)
      end
  
      if(gripper_connected[2]):
          rq_reset_and_activate("3", reset)
      end
  
      if(gripper_connected[3]):
          rq_reset_and_activate("4", reset)
      end
  end
  
  def rq_reset_and_activate(gripper_socket="1", reset=False):
      if(reset):
          rq_reset(gripper_socket)
          rq_activate_and_wait(gripper_socket)
      elif(not rq_is_gripper_activated(gripper_socket)):
          rq_activate_and_wait(gripper_socket)
      end
  end
  
  def rq_reset(gripper_socket="1"):
      rq_set_var("ACT", 0, gripper_socket)
      rq_set_var("ATR", 0, gripper_socket)
  
      while(not rq_get_var("ACT", 1, gripper_socket) == 0 or not rq_get_var("STA", 1, gripper_socket) == 0):
          rq_set_var("ACT", 0, gripper_socket)
          rq_set_var("ATR", 0, gripper_socket)
          sync()
      end
  
      sleep(0.5)
  end
  
  def rq_auto_release_open_and_wait(gripper_socket="1"):
      rq_set_var("ATR",0, gripper_socket)
      rq_set_var("ARD",0, gripper_socket)
      rq_set_var("ACT",1, gripper_socket)
      sleep(0.1)
      rq_set_var("ATR",1, gripper_socket)
  
      rq_wait_autorelease_completed(gripper_socket)
  end
  
  def rq_auto_release_close_and_wait(gripper_socket="1"):
      rq_set_var("ATR",0, gripper_socket)
      rq_set_var("ARD",1, gripper_socket)
      rq_set_var("ACT",1, gripper_socket)
      sleep(0.1)
      rq_set_var("ATR",1, gripper_socket)
  
      rq_wait_autorelease_completed(gripper_socket)
  end
  
  def rq_wait_autorelease_completed(gripper_socket="1"):
      remainingRetries = 20
      gFLT = rq_get_var("FLT", 2, gripper_socket)
  
      while(not is_FLT_autorelease_in_progress(gFLT) and remainingRetries > 0):
          remainingRetries = remainingRetries - 1
          gFLT = rq_get_var("FLT", 2, gripper_socket)
          sleep(0.1)
      end
  
      remainingRetries = 100
      gFLT = rq_get_var("FLT", 2, gripper_socket)
  
      while(not is_FLT_autorelease_completed(gFLT) and remainingRetries > 0):
          remainingRetries = remainingRetries - 1
          gFLT = rq_get_var("FLT", 2, gripper_socket)
          sleep(0.1)
      end
  end
  
  def rq_set_force(force, gripper_socket="1"):
      force = floor(scale(force, [0, 255], [0.0, 255.0]))
      rq_set_var("FOR", force, gripper_socket)
  end
  
  def rq_set_speed(speed, gripper_socket="1"):
      speed = floor(scale(speed, [0, 255], [0.0, 255.0]))
      rq_set_var("SPE", speed, gripper_socket)
  end
  
  def rq_open(gripper_socket="1"):
      rq_move(0, gripper_socket)
  end
  
  def rq_close(gripper_socket="1"):
      rq_move(255, gripper_socket)
  end
  
  def rq_open_and_wait(gripper_socket="1"):
      rq_move_and_wait(0, gripper_socket)
  end
  
  def rq_close_and_wait(gripper_socket="1"):
      rq_move_and_wait(255, gripper_socket)
  end
  
  def rq_move(pos, gripper_socket="1"):
      rq_set_pos(pos, gripper_socket)
      rq_go_to(gripper_socket)
  end
  
  def rq_move_and_wait(pos, gripper_socket="1"):
      rq_move(pos, gripper_socket)
  
      while (not rq_is_motion_complete(gripper_socket)):
          # wait for motion completed
          sync()
      end
  end
  
  def rq_wait_for_pos_request(pos, gripper_socket="1"):
      gPRE = rq_get_var("PRE", 3, gripper_socket)
  
      while (gPRE != pos):
          rq_set_var("POS", pos, gripper_socket)
          sync()
          gPRE = rq_get_var("PRE", 3, gripper_socket)
      end
  end
  
  def rq_wait_pos_spe_for_request(pos, speed, force, gripper_socket="1"):
      gPRE = rq_get_var("PRE", 3, gripper_socket)
  
      while (gPRE != pos):
          rq_set_pos_spe_for_var(pos, speed, force, gripper_socket)
          sync()
          gPRE = rq_get_var("PRE", 3, gripper_socket)
      end
  end
  
  def rq_wait_for_pos(pos, gripper_socket="1"):
      rq_wait_for_pos_request(pos, gripper_socket)
  
      # Wait for the gripper motion to complete
      while (not rq_is_motion_complete(gripper_socket)):
          # wait for motion completed
          sync()
          rq_set_var("GTO", 1, gripper_socket)
      end
  end
  
  def rq_wait(gripper_socket="1"):
      # Wait for the gripper motion to complete
      while (not rq_is_motion_complete(gripper_socket)):
          sync()
          # The following patch is for Robotiq's Camera issue when communication is lost, but not the activation
          # the communication driver reset the GTO bit
          rq_set_var("GTO", 1, gripper_socket)
      end
  end
  
  def rq_wait_for_object_detected(gripper_socket="1"):
      # Wait the object detection
      while (not rq_is_object_detected(gripper_socket)):
          sync()
      end
  end
  
  # set the position
  def rq_set_pos(pos, gripper_socket="1"):
      pos = floor(scale(pos, [0, 255], [0.0, 255.0]))
      rq_set_var("POS", pos, gripper_socket)
      rq_wait_for_pos_request(pos, gripper_socket)
  end
  
  def rq_set_pos_spd_for(pos, speed, force, gripper_socket="1"):
      pos = floor(scale(pos, [0, 255], [0.0, 255.0]))
      speed = floor(scale(speed, [0, 255], [0.0, 255.0]))
      force = floor(scale(force, [0, 255], [0.0, 255.0]))
  
      rq_set_pos_spe_for_var(pos, speed, force, gripper_socket)
  end
  
  def rq_set_gripper_max_current_mA(current_mA, gripper_socket="1"):
      current = floor(current_mA / 10)
  
      rq_set_var("MSC", current, gripper_socket)
      current_read = rq_get_var("MSC", 1, gripper_socket)
  
      while(current_read != current):
          rq_set_var("MSC", current, gripper_socket)
          current_read = rq_get_var("MSC", 1, gripper_socket)
      end
  end
  
  def rq_set_gripper_mode(mode, gripper_socket="1"):
      rq_set_var("MOD", mode, gripper_socket)
  end
  
  def rq_set_gripper_max_cur(current_mA, gripper_socket="1"):
      rq_set_gripper_max_current_mA(current_mA, gripper_socket)
  end
  
  def rq_get_gripper_max_current_mA(gripper_socket="1"):
      current = rq_get_var("MSC", 1, gripper_socket)
  
      if(current == -1):
          current_mA = current
      else:
          current_mA = current * 10
      end
  
      return current_mA
  end
  
  def rq_get_gripper_max_cur(gripper_socket="1"):
      return rq_get_gripper_max_current_mA(gripper_socket)
  end
  
  def rq_set_max_current_for_all_grippers():
      current_mA = rq_get_max_current_mA()
  
      if(gripper_connected[0]):
          rq_set_gripper_max_current_mA(current_mA, "1")
      end
  
      if(gripper_connected[1]):
          rq_set_gripper_max_current_mA(current_mA, "2")
      end
  
      if(gripper_connected[2]):
          rq_set_gripper_max_current_mA(current_mA, "3")
      end
  
      if(gripper_connected[3]):
          rq_set_gripper_max_current_mA(current_mA, "4")
      end
  end
  
  def rq_get_max_current_mA():
      max_current_mA = 0
  
      if(rq_current_limit_enabled):
          nb_connected_grippers = rq_get_nb_connected_grippers()
  
          if(nb_connected_grippers == 1):
              max_current_mA = 600
          elif(nb_connected_grippers > 1):
              max_current_mA = 450
          end
      else:
  
      end
  
      return max_current_mA
  end
  
  def rq_get_nb_connected_grippers():
      nb_connected_grippers = 0
  
      if(gripper_connected[0]):
          nb_connected_grippers = nb_connected_grippers + 1
      end
  
      if(gripper_connected[1]):
          nb_connected_grippers = nb_connected_grippers + 1
      end
  
      if(gripper_connected[2]):
          nb_connected_grippers = nb_connected_grippers + 1
      end
  
      if(gripper_connected[3]):
          nb_connected_grippers = nb_connected_grippers + 1
      end
  
      return nb_connected_grippers
  end
  
  def rq_list_of_bytes_to_value(list_of_bytes):
      value = -1
  
      # response list length
      if (list_of_bytes[0] == 1):
          value = list_of_bytes[1] - 48
      elif (list_of_bytes[0] == 2):
          value = (list_of_bytes[1] - 48) * 10 + (list_of_bytes[2] - 48)
      elif (list_of_bytes[0] == 3):
          value = (list_of_bytes[1] - 48) * 100 + (list_of_bytes[2] - 48) * 10 + (list_of_bytes[3] - 48)
      end
  
      return value
  end
  
  def rq_is_motion_complete(gripper_socket="1"):
      gOBJ = rq_get_var("OBJ", 1, gripper_socket)
      sync()
      return is_OBJ_gripper_at_position(gOBJ) or is_OBJ_object_detected(gOBJ)
  end
  
  def rq_is_gripper_activated(gripper_socket="1"):
      gSTA = rq_get_var("STA", 1, gripper_socket)
      sync()
      return is_STA_gripper_activated(gSTA)
  end
  
  def rq_is_object_detected(gripper_socket="1"):
      gOBJ = rq_get_var("OBJ", 1, gripper_socket)
      sync()
      return is_OBJ_object_detected(gOBJ)
  end
  
  def rq_current_pos(gripper_socket="1"):
      gPOS = rq_get_var("POS", 1, gripper_socket)
      sync()
      return gPOS
  end
  
  def rq_motor_current(gripper_socket="1"):
      rq_current = rq_get_var("COU", 1, gripper_socket)
      sync()
      return rq_current * 10
  end
  
  def rq_print_connected_grippers():
      if(gripper_connected[0]):
          textmsg("Gripper 1 : ", "connected and socket open.")
      end
  
      if (gripper_connected[1]):
          textmsg("Gripper 2 : ", "connected and socket open.")
      end
  
      if (gripper_connected[2]):
          textmsg("Gripper 3 : ", "connected and socket open.")
      end
  
      if (gripper_connected[3]):
          textmsg("Gripper 4 : ", "connected and socket open.")
      end
  end
  
  def rq_print_gripper_fault_code(gripper_socket="1"):
      gFLT = rq_get_var("FLT", 2, gripper_socket)
  
      if(is_FLT_no_fault(gFLT)):
          textmsg("Gripper Fault : ", "No Fault (0x00)")
      elif (is_FLT_action_delayed(gFLT)):
          textmsg("Gripper Fault : ", "Priority Fault: Action delayed, initialization must be completed prior to action (0x05)")
      elif (is_FLT_not_activated(gFLT)):
          textmsg("Gripper Fault : ", "Priority Fault: The activation must be set prior to action (0x07)")
      elif (is_FLT_autorelease_in_progress(gFLT)):
          textmsg("Gripper Fault : ", "Minor Fault: Automatic release in progress (0x0B)")
      elif (is_FLT_overcurrent(gFLT)):
          textmsg("Gripper Fault : ", "Minor Fault: Overcurrent protection triggered (0x0E)")
      elif (is_FLT_autorelease_completed(gFLT)):
          textmsg("Gripper Fault : ", "Major Fault: Automatic release completed (0x0F)")
      else:
          textmsg("Gripper Fault : ", "Unknown Fault")
      end
  end
  
  def rq_print_gripper_num_cycles(gripper_socket="1"):
      num_cycles = rq_get_var("NCY", 1, gripper_socket)
  
      if(num_cycles == -1):
          textmsg("Gripper Cycle Number : ", "Number of cycles is unreachable.")
      else:
          textmsg("Gripper Cycle Number : ", num_cycles)
      end
  end
  
  def rq_print_gripper_driver_state(gripper_socket="1"):
      driver_state = rq_get_var("DST", 1, gripper_socket)
  
      if(driver_state == 0):
          textmsg("Gripper Driver State : ", "RQ_STATE_INIT")
      elif(driver_state == 1):
          textmsg("Gripper Driver State : ", "RQ_STATE_LISTEN")
      elif(driver_state == 2):
          textmsg("Gripper Driver State : ", "RQ_STATE_READ_INFO")
      elif(driver_state == 3):
          textmsg("Gripper Driver State : ", "RQ_STATE_ACTIVATION")
      else:
          textmsg("Gripper Driver State : ", "RQ_STATE_RUN")
      end
  end
  
  def rq_print_gripper_serial_number(gripper_socket="1"):
      serial_number = rq_get_var_string("SNU", 1, gripper_socket)
      textmsg("Gripper Serial Number : ", serial_number)
  end
  
  def rq_print_gripper_firmware_version(gripper_socket="1"):
      firmware_version = rq_get_var_string("FWV", 1, gripper_socket)
      textmsg("Gripper Firmware Version : ", firmware_version)
  end
  
  def rq_print_gripper_driver_version(gripper_socket="1"):
      driver_version = rq_get_var_string("VER", 1, gripper_socket)
      textmsg("Gripper Driver Version : ", driver_version)
  end
  
  def rq_print_gripper_connection_state(gripper_socket="1"):
      connection_state = rq_get_var("PCO", 1, gripper_socket)
  
      if (connection_state == 0):
          textmsg("Gripper Connection State : ", "No connection problem detected")
      else:
          textmsg("Gripper Connection State : ", "Connection problem detected")
      end
  end
  
  # Returns True if list_of_bytes is [3, 'a', 'c', 'k']
  def is_ack(list_of_bytes):
  
      # list length is not 3
      if (list_of_bytes[0] != 3):
          return False
      end
  
      # first byte not is 'a'?
      if (list_of_bytes[1] != 97):
          return False
      end
  
      # first byte not is 'c'?
      if (list_of_bytes[2] != 99):
          return False
      end
  
      # first byte not is 'k'?
      if (list_of_bytes[3] != 107):
          return False
      end
  
      return True
  end
  
  # Returns True if list_of_bytes is not [3, 'a', 'c', 'k']
  def is_not_ack(list_of_bytes):
      if (is_ack(list_of_bytes)):
          return False
      else:
          return True
      end
  end
  
  def is_STA_gripper_activated (gSTA):
      if (gSTA == 3):
          return True
      end
  
      return False
  end
  
  def is_OBJ_object_detected (gOBJ):
      if (gOBJ == 1 or gOBJ == 2):
          return True
      end
  
      return False
  end
  
  def is_OBJ_gripper_at_position (gOBJ):
      if (gOBJ == 3):
          return True
      end
  
      return False
  end
  
  def is_not_OBJ_gripper_at_position (gOBJ):
      if (is_OBJ_gripper_at_position(gOBJ)):
          return False
      else:
          return True
      end
  end
  
  #### GTO Section ####
  def rq_stop(gripper_socket="1"):
      rq_set_var("GTO", 0, gripper_socket)
  end
  
  def rq_set_GTO_and_wait(value, gripper_socket="1"):
      rq_set_var("GTO" ,value, gripper_socket)
      while(not is_GTO(value, rq_get_var("GTO", 1, gripper_socket))):
        sync()
      end
  end
  
  def rq_go_to(gripper_socket="1"):
      rq_set_var("GTO", 1, gripper_socket)
  end
  
  
  def is_GTO(goto_value, rGTO):
      return rGTO == goto_value
  end
  #### GTO Section ####
  
  def is_FLT_no_fault(gFLT):
      return gFLT == 0
  end
  
  def is_FLT_warning(gFLT):
      return gFLT >= 1 and gFLT <= 7
  end
  
  def is_FLT_faulted(gFLT):
      return gFLT >= 8
  end
  
  def is_FLT_action_delayed(gFLT):
      return gFLT == 5
  end
  
  def is_FLT_not_activated(gFLT):
      return gFLT == 7
  end
  
  def is_FLT_autorelease_in_progress(gFLT):
      return gFLT == 11
  end
  
  def is_FLT_overcurrent(gFLT):
      return gFLT == 14
  end
  
  def is_FLT_autorelease_completed(gFLT):
      return gFLT == 15
  end
  
  def rq_set_var(var_name, var_value, gripper_socket="1"):
      index = rq_socket_to_index(gripper_socket)
  
      enter_critical
  
      if (var_name == "ACT"):
          rq_write_act[index] = var_value
          rq_write_act_request[index] = True
      elif (var_name == "GTO"):
          rq_write_gto[index] = var_value
          rq_write_gto_request[index] = True
      elif (var_name == "ATR"):
          rq_write_atr[index] = var_value
          rq_write_atr_request[index] = True
      elif (var_name == "ARD"):
          rq_write_ard[index] = var_value
          rq_write_ard_request[index] = True
      elif (var_name == "FOR"):
          rq_write_for[index] = var_value
          rq_write_pos_request[index] = True
      elif (var_name == "SPE"):
          rq_write_spe[index] = var_value
          rq_write_pos_request[index] = True
      elif (var_name == "POS"):
          rq_write_pos[index] = var_value
          rq_write_pos_request[index] = True
      elif (var_name == "LBP"):
          rq_write_lbp[index] = var_value
          rq_write_lbp_request[index] = True
      elif (var_name == "LRD"):
          rq_write_lrd[index] = var_value
          rq_write_lrd_request[index] = True
      elif (var_name == "LBL"):
          rq_write_lbl[index] = var_value
          rq_write_lbl_request[index] = True
      elif (var_name == "LGN"):
          rq_write_lgn[index] = var_value
          rq_write_lgn_request[index] = True
      elif (var_name == "MSC"):
          rq_write_msc[index] = var_value
          rq_write_msc_request[index] = True
      elif (var_name == "MOD"):
          rq_write_mod[index] = var_value
          rq_write_mod_request[index] = True
      end
  
      exit_critical
  
      if (var_name == "ACT"):
          while(rq_write_act_request[index]):
              sync()
          end
      elif (var_name == "GTO"):
          while(rq_write_gto_request[index]):
              sync()
          end
      elif (var_name == "ATR"):
          while(rq_write_atr_request[index]):
              sync()
          end
      elif (var_name == "ARD"):
          while(rq_write_ard_request[index]):
              sync()
          end
      elif (var_name == "FOR"):
          while(rq_write_pos_request[index]):
              sync()
          end
      elif (var_name == "SPE"):
          while(rq_write_pos_request[index]):
              sync()
          end
      elif (var_name == "POS"):
          while(rq_write_pos_request[index]):
              sync()
          end
      elif (var_name == "LBP"):
          while(rq_write_lbp_request[index]):
              sync()
          end
      elif (var_name == "LRD"):
          while(rq_write_lrd_request[index]):
              sync()
          end
      elif (var_name == "LBL"):
          while(rq_write_lbl_request[index]):
              sync()
          end
      elif (var_name == "LGN"):
          while(rq_write_lgn_request[index]):
              sync()
          end
      elif (var_name == "MSC"):
          while(rq_write_msc_request[index]):
              sync()
          end
      elif (var_name == "MOD"):
          while(rq_write_mod_request[index]):
              sync()
          end
      end
  end
  
  def rq_set_pos_spe_for_var(pos, speed, force, gripper_socket="1"):
      index = rq_socket_to_index(gripper_socket)
  
      enter_critical
  
      rq_write_for[index] = force
      rq_write_spe[index] = speed
      rq_write_pos[index] = pos
      rq_write_pos_request[index] = True
  
      exit_critical
  end
  
  def rq_get_var(var_name, nbr_bytes, gripper_socket="1"):
      index = rq_socket_to_index(gripper_socket)
      var_value = -1
  
      if (var_name == "ACT"):
          enter_critical
          rq_read_act_req[index] = True
          exit_critical
          while(rq_read_act_req[index]):
              sync()
          end
          var_value = rq_read_act[index]
  
      elif (var_name == "GTO"):
          enter_critical
          rq_read_gto_req[index] = True
          exit_critical
          while(rq_read_gto_req[index]):
              sync()
          end
          var_value = rq_read_gto[index]
  
      elif (var_name == "FOR"):
          enter_critical
          rq_read_for_req[index] = True
          exit_critical
          while(rq_read_for_req[index]):
              sync()
          end
          var_value = rq_read_for[index]
  
      elif (var_name == "SPE"):
          enter_critical
          rq_read_spe_req[index] = True
          exit_critical
          while(rq_read_spe_req[index]):
              sync()
          end
          var_value = rq_read_spe[index]
  
      elif (var_name == "OBJ"):
          enter_critical
          rq_read_obj_req[index] = True
          exit_critical
          while(rq_read_obj_req[index]):
              sync()
          end
          var_value = rq_read_obj[index]
  
      elif (var_name == "STA"):
          enter_critical
          rq_read_sta_req[index] = True
          exit_critical
          while(rq_read_sta_req[index]):
              sync()
          end
          var_value = rq_read_sta[index]
  
      elif (var_name == "FLT"):
          enter_critical
          rq_read_flt_req[index] = True
          exit_critical
          while(rq_read_flt_req[index]):
              sync()
          end
          var_value = rq_read_flt[index]
  
      elif (var_name == "POS"):
          enter_critical
          rq_read_pos_req[index] = True
          exit_critical
          while(rq_read_pos_req[index]):
              sync()
          end
          var_value = rq_read_pos[index]
  
      elif (var_name == "PRE"):
          enter_critical
          rq_read_pre_req[index] = True
          exit_critical
          while(rq_read_pre_req[index]):
              sync()
          end
          var_value = rq_read_pre[index]
  
      elif (var_name == "LBP"):
          enter_critical
          rq_read_lbp_req[index] = True
          exit_critical
          while(rq_read_lbp_req[index]):
              sync()
          end
          var_value = rq_read_lbp[index]
  
      elif (var_name == "LRD"):
          enter_critical
          rq_read_lrd_req[index] = True
          exit_critical
          while(rq_read_lrd_req[index]):
              sync()
          end
          var_value = rq_read_lrd[index]
  
      elif (var_name == "LBL"):
          enter_critical
          rq_read_lbl_req[index] = True
          exit_critical
          while(rq_read_lbl_req[index]):
              sync()
          end
          var_value = rq_read_lbl[index]
  
      elif (var_name == "LGN"):
          enter_critical
          rq_read_lgn_req[index] = True
          exit_critical
          while(rq_read_lgn_req[index]):
              sync()
          end
          var_value = rq_read_lgn[index]
  
      elif (var_name == "MSC"):
          enter_critical
          rq_read_msc_req[index] = True
          exit_critical
          while(rq_read_msc_req[index]):
              sync()
          end
          var_value = rq_read_msc[index]
  
      elif (var_name == "MOD"):
          enter_critical
          rq_read_mod_req[index] = True
          exit_critical
          while(rq_read_mod_req[index]):
              sync()
          end
          var_value = rq_read_mod[index]
  
      elif (var_name == "NCY"):
          enter_critical
          rq_read_ncy_req[index] = True
          exit_critical
          while(rq_read_ncy_req[index]):
              sync()
          end
          var_value = rq_read_ncy[index]
  
      elif (var_name == "PCO"):
          enter_critical
          rq_read_pco_req[index] = True
          exit_critical
          while(rq_read_pco_req[index]):
              sync()
          end
          var_value = rq_read_pco[index]
  
      elif (var_name == "DST"):
          enter_critical
          rq_read_dst_req[index] = True
          exit_critical
          while(rq_read_dst_req[index]):
              sync()
          end
          var_value = rq_read_dst[index]
  
      end
  
      return var_value
  end
  
  def rq_get_var_string(var_name, nbr_bytes, gripper_socket="1"):
      index = rq_socket_to_index(gripper_socket)
      var_value = ""
  
      enter_critical
  
      if (var_name == "SNU"):
          if(gripper_socket == "1"):
              var_value = rq_read_snu_1
          elif(gripper_socket == "2"):
              var_value = rq_read_snu_2
          elif(gripper_socket == "3"):
              var_value = rq_read_snu_3
          elif(gripper_socket == "4"):
              var_value = rq_read_snu_4
          end
      elif (var_name == "FWV"):
          if(gripper_socket == "1"):
              var_value = rq_read_fwv_1
          elif(gripper_socket == "2"):
              var_value = rq_read_fwv_2
          elif(gripper_socket == "3"):
              var_value = rq_read_fwv_3
          elif(gripper_socket == "4"):
              var_value = rq_read_fwv_4
          end
      elif (var_name == "VER"):
          if(gripper_socket == "1"):
              var_value = rq_read_ver_1
          elif(gripper_socket == "2"):
              var_value = rq_read_ver_2
          elif(gripper_socket == "3"):
              var_value = rq_read_ver_3
          elif(gripper_socket == "4"):
              var_value = rq_read_ver_4
          end
      end
  
      exit_critical
  
      return var_value
  end
  
  def rq_is_object_validated(gripper_selected, gripper_socket="1"):
      if(gripper_selected):
          if(rq_is_object_detected(gripper_socket)):
              return True
          else:
              return False
          end
      else:
          return True
      end
  end
  
  ############################################
  # normalized functions (maps 0-100 to 0-255)
  ############################################
  def rq_set_force_norm(force_norm, gripper_socket="1"):
      force_gripper = norm_to_gripper(force_norm)
      rq_set_force(force_gripper, gripper_socket)
  end
  
  def rq_set_speed_norm(speed_norm, gripper_socket="1"):
      speed_gripper = norm_to_gripper(speed_norm)
      rq_set_speed(speed_gripper, gripper_socket)
  end
  
  def rq_move_norm(pos_norm, gripper_socket="1"):
      pos_gripper = norm_to_gripper(pos_norm)
      rq_move(pos_gripper, gripper_socket)
  end
  
  def rq_move_and_wait_norm(pos_norm, gripper_socket="1"):
      pos_gripper = norm_to_gripper(pos_norm)
      rq_move_and_wait(pos_gripper, gripper_socket)
  end
  
  def rq_set_pos_norm(pos_norm, gripper_socket="1"):
      pos_gripper = norm_to_gripper(pos_norm)
      rq_set_pos(pos_gripper, gripper_socket)
  end
  
  def rq_current_pos_norm(gripper_socket="1"):
      pos_gripper = rq_current_pos(gripper_socket)
      pos_norm = gripper_to_norm(pos_gripper)
      return pos_norm
  end
  
  def gripper_to_norm(value_gripper):
      value_norm = (value_gripper / 255) * 100
      return floor(value_norm)
  end
  
  def norm_to_gripper(value_norm):
      value_gripper = (value_norm / 100) * 255
      return ceil(value_gripper)
  end
  
  def rq_get_position():
      return rq_current_pos_norm()
  end
  
  def rq_gripper_led_on(gripper_socket="1"):
      rq_set_var("LBP",0, gripper_socket)
  end
  
  def rq_gripper_led_off(gripper_socket="1"):
      rq_set_var("LBP",1, gripper_socket)
      rq_set_var("LRD",0, gripper_socket)
      rq_set_var("LBL",0, gripper_socket)
      rq_set_var("LGN",0, gripper_socket)
  end
  
  def rq_gripper_led_force_red(gripper_socket="1"):
      rq_set_var("LBP",1, gripper_socket)
      rq_set_var("LRD",1, gripper_socket)
      rq_set_var("LBL",0, gripper_socket)
      rq_set_var("LGN",0, gripper_socket)
  end
  
  def rq_gripper_led_force_blue(gripper_socket="1"):
      rq_set_var("LBP",1, gripper_socket)
      rq_set_var("LRD",0, gripper_socket)
      rq_set_var("LBL",1, gripper_socket)
      rq_set_var("LGN",0, gripper_socket)
  end
  
  def rq_gripper_led_force_green(gripper_socket="1"):
      rq_set_var("LBP",1, gripper_socket)
      rq_set_var("LRD",0, gripper_socket)
      rq_set_var("LBL",0, gripper_socket)
      rq_set_var("LGN",1, gripper_socket)
  end
  
  def rq_gripper_led_force_purple(gripper_socket="1"):
      rq_set_var("LBP",1, gripper_socket)
      rq_set_var("LRD",1, gripper_socket)
      rq_set_var("LBL",1, gripper_socket)
      rq_set_var("LGN",0, gripper_socket)
  end
  
  ############################################
  # mm/inches functions
  ############################################
  gripper_closed_norm = [100, 100, 100, 100]
  gripper_open_norm = [0, 0, 0, 0]
  gripper_closed_mm = [0, 0, 0, 0]
  gripper_open_mm = [50, 50, 50, 50]
  
  def rq_current_pos_mm(gripper_socket=1):
      pos_gripper = rq_current_pos(gripper_socket)
      pos_mm = gripper_to_mm(pos_gripper, gripper_socket)
      return round_value_2_dec(pos_mm)
  end
  
  def rq_current_pos_inches(gripper_socket=1):
      pos_gripper = rq_current_pos(gripper_socket)
      pos_mm = gripper_to_mm(pos_gripper, gripper_socket)
      pos_in = pos_mm / 25.4
      return round_value_2_dec(pos_in)
  end
  
  def rq_move_mm(pos_mm, gripper_socket=1):
      pos_gripper = mm_to_gripper(pos_mm, gripper_socket)
      rq_move(pos_gripper, gripper_socket)
  end
  
  def rq_move_and_wait_mm(pos_mm, gripper_socket=1):
      pos_gripper = mm_to_gripper(pos_mm, gripper_socket)
      rq_move_and_wait(pos_gripper, gripper_socket)
  end
  
  def rq_move_inches(pos_in, gripper_socket=1):
      pos_mm = pos_in * 25.4
      rq_move_mm(pos_mm, gripper_socket)
  end
  
  def rq_move_and_wait_inches(pos_in, gripper_socket=1):
      pos_mm = pos_in * 25.4
      rq_move_and_wait_mm(pos_mm, gripper_socket)
  end
  
  def get_closed_norm(gripper_socket):
      return gripper_closed_norm[gripper_socket - 1]
  end
  
  def get_open_norm(gripper_socket):
      return gripper_open_norm[gripper_socket - 1]
  end
  
  def get_closed_mm(gripper_socket):
      return gripper_closed_mm[gripper_socket - 1]
  end
  
  def get_open_mm(gripper_socket):
      return gripper_open_mm[gripper_socket - 1]
  end
  
  def set_closed_norm(closed_norm, gripper_socket):
      gripper_closed_norm[gripper_socket - 1] = closed_norm
  end
  
  def set_open_norm(open_norm, gripper_socket):
      gripper_open_norm[gripper_socket - 1] = open_norm
  end
  
  def set_closed_mm(closed_mm, gripper_socket):
      gripper_closed_mm[gripper_socket - 1] = closed_mm
  end
  
  def set_open_mm(open_mm, gripper_socket):
      gripper_open_mm[gripper_socket - 1] = open_mm
  end
  
  def gripper_to_mm(value_gripper, gripper_socket):
      closed_norm = get_closed_norm(gripper_socket)
      open_norm = get_open_norm(gripper_socket)
      closed_mm = get_closed_mm(gripper_socket)
      open_mm = get_open_mm(gripper_socket)
  
      value_norm = (value_gripper / 255) * 100
  
      slope = (closed_mm - open_mm) / (closed_norm - open_norm)
      value_mm = slope * (value_norm - closed_norm) + closed_mm
  
      if (value_mm > open_mm):
          value_mm_limited = open_mm
      elif (value_mm < closed_mm):
          value_mm_limited = closed_mm
      else:
          value_mm_limited = value_mm
      end
  
      return value_mm_limited
  end
  
  def mm_to_gripper(value_mm, gripper_socket):
      closed_norm = get_closed_norm(gripper_socket)
      open_norm = get_open_norm(gripper_socket)
      closed_mm = get_closed_mm(gripper_socket)
      open_mm = get_open_mm(gripper_socket)
  
      slope = (closed_norm - open_norm) / (closed_mm - open_mm)
      value_norm = (value_mm - closed_mm) * slope + closed_norm
  
      value_gripper = value_norm * 255 / 100
  
      if (value_gripper > 255):
          value_gripper_limited = 255
      elif (value_gripper < 0):
          value_gripper_limited = 0
      else:
          value_gripper_limited = round_value(value_gripper)
      end
  
      return value_gripper_limited
  end
  
  def round_value(value):
      value_mod = value % 1
  
      if(value_mod < 0.5):
          return floor(value)
      else:
          return ceil(value)
      end
  end
  
  def round_value_2_dec(value):
      value_x_100 = value * 100
      value_x_100_rounded = round_value(value_x_100)
      return value_x_100_rounded / 100
  end
  
  def clear_socket_buffer(gripper_socket="1", read_timeout = 0.1):
      rq_comm_clear_socket_buffer_enabled[rq_socket_to_index(gripper_socket)] = True
  end
  
  def rq_gripper_id_to_ascii(gripper_id):
      if(gripper_id == "1"):
          return 57
      elif(gripper_id == "2"):
          return 50
      elif(gripper_id == "3"):
          return 51
      elif(gripper_id == "4"):
          return 52
      end
  end
  
  def scale(value, rawRange, scaledRange):
      def computeSlope(inputRange, outputRange):
          outputRangeDelta = outputRange[1] - outputRange[0]
          inputRangeDelta = inputRange[1] - inputRange[0]
  
          if (inputRangeDelta == 0):
              return 0
          else:
              return outputRangeDelta / inputRangeDelta
          end
      end
  
      def computeIntercept(slope, inputRange, outputRange):
          return outputRange[0] - (slope * inputRange[0])
      end
  
      def clipScaledValue(outputScaledValue, outputRange):
          if (outputRange[0] < outputRange[1]):
              return clipWhenLowerLimitIsLessThanHigher(outputScaledValue, outputRange)
          else:
              return clipWhenLowerLimitIsGreaterThanHigherLimit(outputScaledValue, outputRange)
          end
      end
  
      def clipWhenLowerLimitIsGreaterThanHigherLimit(outputScaledValue, outputRange):
          if (outputScaledValue < outputRange[1]):
              return outputRange[1]
          elif (outputScaledValue > outputRange[0]):
              return outputRange[0]
          else:
              return outputScaledValue
          end
      end
  
      def clipWhenLowerLimitIsLessThanHigher(outputScaledValue, outputRange):
          if (outputScaledValue < outputRange[0]):
              return outputRange[0]
          elif (outputScaledValue > outputRange[1]):
              return outputRange[1]
          else:
              return outputScaledValue
          end
      end
  
      slope = computeSlope(rawRange, scaledRange)
      intercept = computeIntercept(slope, rawRange, scaledRange)
      scaledValue = slope * value + intercept
      return clipScaledValue(scaledValue, scaledRange)
  end
  
  def limit(value, range):
      return scale(value, range, range)
  end
  
  
  rq_init_comm_if_connected(9, "1")
  rq_init_comm_if_connected(2, "2")
  rq_init_comm_if_connected(3, "3")
  rq_init_comm_if_connected(4, "4")
  rq_print_connected_grippers()
  rq_gripper_communication_thread = run rq_gripper_communication()
  set_closed_norm(100.0, 1)
  set_open_norm(0.0, 1)
  set_closed_mm(0.0, 1)
  set_open_mm(50.0, 1)
  set_closed_norm(100.0, 2)
  set_open_norm(0.0, 2)
  set_closed_mm(0.0, 2)
  set_open_mm(50.0, 2)
  set_closed_norm(100.0, 3)
  set_open_norm(0.0, 3)
  set_closed_mm(0.0, 3)
  set_open_mm(50.0, 3)
  set_closed_norm(100.0, 4)
  set_open_norm(0.0, 4)
  set_closed_mm(0.0, 4)
  set_open_mm(50.0, 4)
  rq_current_limit_enabled = False
  while(not rq_gripper_communication_thread_started):
      sync()
  end
  # end: URCap Installation Node
  global Waypoint_13_p=p[.463075378858, -.033118898203, .367768326041, -2.244549547112, 2.186980266689, -.146698143579]
  global Waypoint_13_q=[0.2635507583618164, -1.4171207708171387, -1.6266908645629883, -1.6176563702025355, 1.4933080673217773, 0.2373518943786621]
  global Waypoint_4_p=p[.519156522835, .251252931368, .258081315581, -2.029121921385, 2.381370893788, -.062165587138]
  global Waypoint_4_q=[0.7007012367248535, -1.7337714634337367, -1.5767345428466797, -1.3898499769023438, 1.531332015991211, 0.8616147041320801]
  global Waypoint_14_p=p[.519156775937, .251250178495, .235923552770, -1.913430265306, 2.255660501523, .225490494162]
  global Waypoint_14_q=[0.6059670448303223, -1.698531290093893, -1.7320833206176758, -1.1207493108562012, 1.7381596565246582, 0.7851557731628418]
  global Waypoint_5_p=p[.476535220460, .292722299991, .269938378660, 2.341548701929, -1.670834425984, .318812430692]
  global Waypoint_5_q=[0.9002838134765625, -1.8036877117552699, -1.4324216842651367, -1.7178675136961878, 1.3416061401367188, 0.5986371040344238]
  global Waypoint_6_p=p[.503578519924, .354187987286, .295750684916, -2.425100303771, 1.909621069420, -.022346319980]
  global Waypoint_6_q=[0.8343544006347656, -1.796575208703512, -1.4153871536254883, -1.445223645572998, 1.560166835784912, 0.5989603996276855]
  global Waypoint_11_p=p[.463069913685, .373635307885, .367778231425, -2.552402103854, 1.792810489584, -.143117491211]
  global Waypoint_11_q=[0.9444355964660645, -1.758153577844137, -1.2712469100952148, -1.6630522213377894, 1.479501724243164, 0.5989480018615723]
  $ 1 "BeforeStart"
  $ 2 "MoveJ"
  $ 3 "Waypoint_13" "breakAfter"
  movej(get_inverse_kin(Waypoint_13_p, qnear=Waypoint_13_q), a=1.3962634015954636, v=1.0471975511965976)
  # begin: URCap Program Node
  #   Source: Robotiq_Grippers, 1.8.3.4198-beta, Robotiq Inc.
  #   Type: Gripper Activate
  $ 4 "Gripper Activate"
  
  kill rq_gripper_communication_thread
  rq_gripper_communication_thread_started = False
  
  rq_init_comm_if_connected(9, "1")
  rq_init_comm_if_connected(2, "2")
  rq_init_comm_if_connected(3, "3")
  rq_init_comm_if_connected(4, "4")
  rq_print_connected_grippers()
  rq_gripper_communication_thread = run rq_gripper_communication()
  
  while(not rq_gripper_communication_thread_started):
      sync()
  end
  
  rq_set_max_current_for_all_grippers()
  
  reset_and_activate = False
  
  rq_activate_all_grippers(False)
  # end: URCap Program Node
  $ 5 "If  not digital_in[4]"
  if (  not  get_standard_digital_in(4)):
    $ 6 "Popup: Postavi skatlo k zadnjemu senzorju :)"
    popup("Postavi skatlo k zadnjemu senzorju :)", "Message", False, False, blocking=True)
    $ 7 "Loop  not digital_in[4]"
    while (  not  get_standard_digital_in(4)):
      $ 8 "'prazen loop ne laufa :)'"
      # 'prazen loop ne laufa :)'
    end
  end
  $ 9 "open_socketsocket_open('192.168.65.102',50000,'student')"
  global open_socket=socket_open("192.168.65.102",50000,"student")
  $ 10 "Loop  not open_socket"
  while (  not  open_socket):
    $ 11 "open_socketsocket_open('192.168.65.102',50000,'student')"
    global open_socket=socket_open("192.168.65.102",50000,"student")
  end
  $ 12 "Robot Program"
  $ 13 "MoveL"
  $ 14 "Waypoint_4" "breakAfter"
  movel(Waypoint_4_p, a=1.2, v=0.25)
  # begin: URCap Program Node
  #   Source: Robotiq_Grippers, 1.8.3.4198-beta, Robotiq Inc.
  #   Type: Gripper
  $ 15 "Gripper Open (2)"
  if not(gripper_connected[1]):
    popup("Gripper 2 must be connected to run this program.", "No connection", False, True, True)
  end
  if not(rq_is_gripper_activated("2")):
    popup("Gripper 2 is not activated. Go to Installation tab > Gripper to activate it and run the program again.", "Not activated", False, True, True)
  end
  rq_set_pos_spd_for(0, 0, 0, "2")
  rq_wait_pos_spe_for_request(0, 0, 0, "2")
  rq_go_to("2")
  rq_wait("2")
  # end: URCap Program Node
  $ 16 "If  not digital_in[5]"
  if (  not  get_standard_digital_in(5)):
    $ 17 "Set DO[5]=On"
    set_standard_digital_out(5, True)
  end
  $ 18 "Loop  not digital_in[5]"
  while (  not  get_standard_digital_in(5)):
    $ 19 "'cakam da se skatla pripelje'"
    # 'cakam da se skatla pripelje'
  end
  $ 20 "Set DO[5]=Off"
  set_standard_digital_out(5, False)
  $ 21 "'tcp ip skatla prispela'"
  # 'tcp ip skatla prispela'
  $ 22 "If open_socket"
  if (open_socket):
    $ 23 "was_sendsocket_send_string('PRISPELA','student')"
    global was_send=socket_send_string("PRISPELA","student")
    $ 24 "Loop  not was_send"
    while (  not  was_send):
      $ 25 "was_sendsocket_send_string('PRISPELA','student')"
      global was_send=socket_send_string("PRISPELA","student")
      $ 26 "Wait: 0.01"
      sleep(0.01)
    end
    $ 27 "Wait: 0.01"
    sleep(0.01)
  end
  $ 28 "MoveL"
  $ 29 "Waypoint_14" "breakAfter"
  movel(Waypoint_14_p, a=1.2, v=0.25)
  $ 30 "'premik za prijem pokrova'"
  # 'premik za prijem pokrova'
  # begin: URCap Program Node
  #   Source: Robotiq_Grippers, 1.8.3.4198-beta, Robotiq Inc.
  #   Type: Gripper
  $ 31 "Gripper Close (2)"
  if not(gripper_connected[1]):
    popup("Gripper 2 must be connected to run this program.", "No connection", False, True, True)
  end
  if not(rq_is_gripper_activated("2")):
    popup("Gripper 2 is not activated. Go to Installation tab > Gripper to activate it and run the program again.", "Not activated", False, True, True)
  end
  rq_set_pos_spd_for(255, 0, 0, "2")
  rq_wait_pos_spe_for_request(255, 0, 0, "2")
  rq_go_to("2")
  rq_wait("2")
  # end: URCap Program Node
  $ 32 "'gripper primer pokrov'"
  # 'gripper primer pokrov'
  $ 33 "Set DO[0]=On"
  set_standard_digital_out(0, True)
  $ 34 "'vkopi napajanje za kljucavnico'"
  # 'vkopi napajanje za kljucavnico'
  $ 35 "'tcp ip skatla odklenjena'"
  # 'tcp ip skatla odklenjena'
  $ 36 "If open_socket"
  if (open_socket):
    $ 37 "was_sendsocket_send_string('ODKLENJENA','student')"
    global was_send=socket_send_string("ODKLENJENA","student")
    $ 38 "Loop  not was_send"
    while (  not  was_send):
      $ 39 "was_sendsocket_send_string('ODKLENJENA','student')"
      global was_send=socket_send_string("ODKLENJENA","student")
      $ 40 "Wait: 0.01"
      sleep(0.01)
    end
    $ 41 "Wait: 0.01"
    sleep(0.01)
  end
  $ 42 "MoveL"
  $ 43 "Waypoint_5" "breakAfter"
  movel(Waypoint_5_p, a=1.2, v=0.25, r=0.01)
  $ 44 "'dvigne pokrov'"
  # 'dvigne pokrov'
  $ 45 "'tcp_ip skatla je odprta'"
  # 'tcp_ip skatla je odprta'
  $ 46 "If open_socket"
  if (open_socket):
    $ 47 "was_sendsocket_send_string('ODPRTA','student')"
    global was_send=socket_send_string("ODPRTA","student")
    $ 48 "Loop  not was_send"
    while (  not  was_send):
      $ 49 "was_sendsocket_send_string('ODPRTA','student')"
      global was_send=socket_send_string("ODPRTA","student")
      $ 50 "Wait: 0.01"
      sleep(0.01)
    end
    $ 51 "Wait: 0.01"
    sleep(0.01)
  end
  $ 52 "Set DO[0]=Off"
  set_standard_digital_out(0, False)
  $ 53 "'izklopi napajanje kljucavice (<4s)'"
  # 'izklopi napajanje kljucavice (<4s)'
  $ 54 "MoveL"
  $ 55 "Waypoint_6" "breakAfter"
  movel(Waypoint_6_p, a=1.2, v=0.25)
  $ 56 "'pokrov premakne k zadnjemu delu skatle'"
  # 'pokrov premakne k zadnjemu delu skatle'
  # begin: URCap Program Node
  #   Source: Robotiq_Grippers, 1.8.3.4198-beta, Robotiq Inc.
  #   Type: Gripper
  $ 57 "Gripper Open (2)"
  if not(gripper_connected[1]):
    popup("Gripper 2 must be connected to run this program.", "No connection", False, True, True)
  end
  if not(rq_is_gripper_activated("2")):
    popup("Gripper 2 is not activated. Go to Installation tab > Gripper to activate it and run the program again.", "Not activated", False, True, True)
  end
  rq_set_pos_spd_for(0, 255, 5, "2")
  rq_wait_pos_spe_for_request(0, 255, 5, "2")
  rq_go_to("2")
  rq_wait("2")
  # end: URCap Program Node
  $ 58 "'odpre prijemalo'"
  # 'odpre prijemalo'
  $ 59 "MoveL"
  $ 60 "Waypoint_11" "breakAfter"
  movel(Waypoint_11_p, a=1.2, v=0.25)
  $ 61 "'stran od skatle'"
  # 'stran od skatle'
  $ 62 "Waypoint_13" "breakAfter"
  movel(Waypoint_13_p, a=1.2, v=0.25)
  $ 63 "'domov = opravi task'"
  # 'domov = opravi task'
  $ 64 "Wait: 2.0"
  sleep(2.0)
  $ 65 "Waypoint_11" "breakAfter"
  movel(Waypoint_11_p, a=1.2, v=0.25)
  $ 66 "'se postavi nad skatlo'"
  # 'se postavi nad skatlo'
  # begin: URCap Program Node
  #   Source: Robotiq_Grippers, 1.8.3.4198-beta, Robotiq Inc.
  #   Type: Gripper
  $ 67 "Gripper Open (2)"
  if not(gripper_connected[1]):
    popup("Gripper 2 must be connected to run this program.", "No connection", False, True, True)
  end
  if not(rq_is_gripper_activated("2")):
    popup("Gripper 2 is not activated. Go to Installation tab > Gripper to activate it and run the program again.", "Not activated", False, True, True)
  end
  rq_set_pos_spd_for(0, 255, 5, "2")
  rq_wait_pos_spe_for_request(0, 255, 5, "2")
  rq_go_to("2")
  rq_wait("2")
  # end: URCap Program Node
  $ 68 "'odpre gripper'"
  # 'odpre gripper'
  $ 69 "Waypoint_6" "breakAfter"
  movel(Waypoint_6_p, a=1.2, v=0.25)
  $ 70 "'se locira pri bunki za prijet'"
  # 'se locira pri bunki za prijet'
  # begin: URCap Program Node
  #   Source: Robotiq_Grippers, 1.8.3.4198-beta, Robotiq Inc.
  #   Type: Gripper
  $ 71 "Gripper Close (2)"
  if not(gripper_connected[1]):
    popup("Gripper 2 must be connected to run this program.", "No connection", False, True, True)
  end
  if not(rq_is_gripper_activated("2")):
    popup("Gripper 2 is not activated. Go to Installation tab > Gripper to activate it and run the program again.", "Not activated", False, True, True)
  end
  rq_set_pos_spd_for(255, 255, 5, "2")
  rq_wait_pos_spe_for_request(255, 255, 5, "2")
  rq_go_to("2")
  rq_wait("2")
  # end: URCap Program Node
  $ 72 "'zapre prijemalo'"
  # 'zapre prijemalo'
  $ 73 "Waypoint_5" "breakAfter"
  movel(Waypoint_5_p, a=1.2, v=0.25, r=0.01)
  $ 74 "'dvigne pokrov'"
  # 'dvigne pokrov'
  $ 75 "Waypoint_14" "breakAfter"
  movel(Waypoint_14_p, a=1.2, v=0.25)
  $ 76 "'pokrov postavi v zacetno pozicijo'"
  # 'pokrov postavi v zacetno pozicijo'
  $ 77 "If open_socket"
  if (open_socket):
    $ 78 "was_sendsocket_send_string('ZAPRTA','student')"
    global was_send=socket_send_string("ZAPRTA","student")
    $ 79 "Loop  not was_send"
    while (  not  was_send):
      $ 80 "was_sendsocket_send_string('ZAPRTA','student')"
      global was_send=socket_send_string("ZAPRTA","student")
      $ 81 "Wait: 0.01"
      sleep(0.01)
    end
    $ 82 "Wait: 0.01"
    sleep(0.01)
  end
  # begin: URCap Program Node
  #   Source: Robotiq_Grippers, 1.8.3.4198-beta, Robotiq Inc.
  #   Type: Gripper
  $ 83 "Gripper Open (2)"
  if not(gripper_connected[1]):
    popup("Gripper 2 must be connected to run this program.", "No connection", False, True, True)
  end
  if not(rq_is_gripper_activated("2")):
    popup("Gripper 2 is not activated. Go to Installation tab > Gripper to activate it and run the program again.", "Not activated", False, True, True)
  end
  rq_set_pos_spd_for(0, 255, 5, "2")
  rq_wait_pos_spe_for_request(0, 255, 5, "2")
  rq_go_to("2")
  rq_wait("2")
  # end: URCap Program Node
  $ 84 "'odpre gripper'"
  # 'odpre gripper'
  $ 85 "Set DO[0]=On"
  set_standard_digital_out(0, True)
  $ 86 "'vklopi napajanje za kljucavnico'"
  # 'vklopi napajanje za kljucavnico'
  $ 87 "Wait: 1.0"
  sleep(1.0)
  $ 88 "Set DO[0]=Off"
  set_standard_digital_out(0, False)
  $ 89 "'izklopi napajanje za kljucavnico'"
  # 'izklopi napajanje za kljucavnico'
  $ 90 "If open_socket"
  if (open_socket):
    $ 91 "was_sendsocket_send_string('ZAKLENJENA','student')"
    global was_send=socket_send_string("ZAKLENJENA","student")
    $ 92 "Loop  not was_send"
    while (  not  was_send):
      $ 93 "was_sendsocket_send_string('ZAKLENJENA','student')"
      global was_send=socket_send_string("ZAKLENJENA","student")
      $ 94 "Wait: 0.01"
      sleep(0.01)
    end
    $ 95 "Wait: 0.01"
    sleep(0.01)
  end
  $ 96 "Waypoint_13" "breakAfter"
  movel(Waypoint_13_p, a=1.2, v=0.25)
  $ 97 "'domov'"
  # 'domov'
  $ 98 "If digital_in[5]"
  if (get_standard_digital_in(5)):
    $ 99 "Set DO[5]=On"
    set_standard_digital_out(5, True)
    $ 100 "'ce je skatla se pri senzorju posljemo naprej'"
    # 'ce je skatla se pri senzorju posljemo naprej'
    $ 101 "'tcp_ip skatla sla naprej'"
    # 'tcp_ip skatla sla naprej'
    $ 102 "If open_socket"
    if (open_socket):
      $ 103 "was_sendsocket_send_string('ODPRAVLJENA','student')"
      global was_send=socket_send_string("ODPRAVLJENA","student")
      $ 104 "Loop  not was_send"
      while (  not  was_send):
        $ 105 "was_sendsocket_send_string('ODPRAVLJENA','student')"
        global was_send=socket_send_string("ODPRAVLJENA","student")
        $ 106 "Wait: 0.01"
        sleep(0.01)
      end
      $ 107 "Wait: 0.01"
      sleep(0.01)
    end
  end
  $ 108 "Loop digital_in[5]"
  while (get_standard_digital_in(5)):
    $ 109 "'cakam da skatla ne bo vec pri senzorju'"
    # 'cakam da skatla ne bo vec pri senzorju'
  end
  $ 110 "Set DO[5]=Off"
  set_standard_digital_out(5, False)
  $ 111 "socket_close('student')"
  socket_close("student")
  $ 112 "Halt"
  halt
end
